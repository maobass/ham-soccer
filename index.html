const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- ÂÖ®ÁîªÈù¢Ë°®Á§∫„ÅÆ„Åü„ÇÅ„ÅÆËøΩÂä†meta„Çø„Ç∞ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>„Åò„ÇÉ„Åå„Çä„Çì„Çπ„É©„Ç§„É†„Çµ„ÉÉ„Ç´„Éº</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            touch-action: auto; /* „Éá„Éï„Ç©„É´„Éà„Åß„É°„Éã„É•„ÉºÊôÇ„ÅØË®±ÂèØ */
            overflow-y: auto; /* „Éá„Éï„Ç©„É´„Éà„Åß„É°„Éã„É•„ÉºÊôÇ„ÅØË®±ÂèØ */
            /* „Éé„ÉÉ„ÉÅ/„ÉÄ„Ç§„Éä„Éü„ÉÉ„ÇØ„Ç¢„Ç§„É©„É≥„ÉâÂØæÂøú„ÅÆ„Åü„ÇÅ„ÅÆsafe-areaË™øÊï¥ */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        
        #root {
            width: 100vw;
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        
        .game-container {
            width: 100vw;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        
        .character-grid-scroll {
            max-height: 60vh;
            overflow-y: auto;
            margin: 30px auto 0 auto;
            width: 100%;
        }

        .character-select-bottom {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: sticky;
            bottom: 0;
            background: #1a1a2e;
            padding-bottom: 24px;
            z-index: 10;
        }

        canvas {
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw;
            max-height: 100vh;
            border: 2px solid #333;
            background: #0066ff;
            touch-action: none;
            display: block;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #fff;
            background: rgba(0, 102, 255, 0.8);
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        .control-btn:active {
            background: rgba(0, 102, 255, 1);
            transform: scale(0.95);
        }
        
        .direction-controls {
            display: flex;
            gap: 10px;
        }
        
        .menu-btn {
            padding: 12px 24px;
            margin: 10px;
            background: #0066ff;
            color: white;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .menu-btn:active {
            background: #0052cc;
            transform: scale(0.95);
        }
        
        .score-display {
            background: #0066ff;
            padding: 15px 30px;
            border-radius: 8px 8px 0 0;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            padding-top: calc(15px + env(safe-area-inset-top));
        }
        
        .game-info {
            text-align: center;
            margin: 20px;
        }
        
        .menu-container {
            text-align: center;
            padding: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #fff;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        @media (orientation: landscape) {
            canvas {
                max-height: 100vh;
            }
            
            .controls {
                bottom: 10px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }
            
            .score-display {
                font-size: 16px;
                padding: 10px 20px;
            }
            
            .control-btn {
                width: 55px;
                height: 55px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 400;
        const GROUND_HEIGHT = 80;
        const SLIME_RADIUS = 40;
        const BALL_RADIUS = 10;
        const GOAL_WIDTH = 80;
        const GOAL_HEIGHT = 120;
        const GRAVITY = 0.6;
        const SLIME_SPEED = 5;
        const SLIME_JUMP_POWER = -12;
        const BALL_DAMPING = 0.99;
        const BALL_BOUNCE_DAMPING = 0.8;
        const MAX_BALL_SPEED = 13;
        
        // BGMÁî®AudioË¶ÅÁ¥†„ÅÆÁÆ°ÁêÜ
        const createAudioManager = () => {
            const bgmAudio = new Audio();
            
            // BGM„Éï„Ç°„Ç§„É´„ÅÆ„Éë„ÇπÔºàÂÖ®„Å¶„ÅÇ„Å™„Åü„ÅÆÊ•ΩÊõ≤Ôºâ
            const bgmFiles = [
                'musics/„Ç∑„É≥„Ç∞„É´„Éô„É´ (Remastered).mp3',
                'musics/„Å©„ÅçÔºÅ.mp3',
                'musics/„ÅØ„ÇÄ„Éñ„É´.mp3',
                'musics/„Å∂„Å°„ÅÇ„Åí.mp3',
                'musics/„Åæ„ÄÅ„Çã„ÄÅ„Å°„ÇÉ„ÄÅ„ÇìÔºÅ.mp3',
                'musics/Èõ®.mp3',
                'musics/Êàë„ÄÖ„ÅØHamCup.mp3',
                'musics/ARE YOU FUMA.mp3',
                'musics/Give &  Love.mp3',
                'musics/HamCupÂõΩÊ≠å.mp3',
                'musics/Hey, yo, what\'s up men_ bro..mp3',
                'musics/Tommy\'s soliloquy 86\'.mp3',
                'musics/„Åä„Éº„Åï„Éº„ÇÜÔºÅ.mp3'
            ];
            
            // „É©„É≥„ÉÄ„É†„Å´BGM„ÇíÈÅ∏Êäû
            const randomBGM = bgmFiles[Math.floor(Math.random() * bgmFiles.length)];
            bgmAudio.src = randomBGM;
            bgmAudio.loop = true;
            bgmAudio.volume = 0.6; // Èü≥ÈáèË™øÊï¥Ôºà0.0-1.0Ôºâ
            
            // ÂäπÊûúÈü≥Áî®„ÅÆWeb Audio APIÔºà„Ç∑„É≥„Éó„É´„Å™ÈõªÂ≠êÈü≥Ôºâ
            let audioContext = null;
            const createAudioContext = () => {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                return audioContext;
            };
            
            const playBeep = (frequency, duration, volume = 0.3) => {
                try {
                    const ctx = createAudioContext();
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, ctx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, ctx.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                    
                    oscillator.start(ctx.currentTime);
                    oscillator.stop(ctx.currentTime + duration);
                } catch (error) {
                    console.log('ÂäπÊûúÈü≥„Ç®„É©„Éº:', error);
                }
            };
            
            return {
                bgm: bgmAudio,
                currentBGM: randomBGM, // ÁèæÂú®„ÅÆBGMÂêç„Çí‰øùÂ≠ò
                bgmFiles: bgmFiles, // BGM„Éï„Ç°„Ç§„É´„É™„Çπ„Éà„Çí‰øùÂ≠ò
                playBGM: async () => {
                    try {
                        bgmAudio.currentTime = 0;
                        await bgmAudio.play();
                        console.log('BGMÈñãÂßã:', randomBGM);
                    } catch (error) {
                        console.log('BGMÂÜçÁîü„Ç®„É©„Éº:', error);
                    }
                },
                stopBGM: () => {
                    bgmAudio.pause();
                    bgmAudio.currentTime = 0;
                },
                playKick: () => {
                    // „Ç≠„ÉÉ„ÇØÈü≥ÔºöÁü≠„ÅÑ‰ΩéÈü≥
                    playBeep(200, 0.1, 0.3);
                },
                playGoal: () => {
                    // „Ç¥„Éº„É´Èü≥ÔºöËèØ„ÇÑ„Åã„Å™‰∏äÊòáÈü≥
                    playBeep(400, 0.2, 0.4);
                    setTimeout(() => playBeep(500, 0.2, 0.4), 100);
                    setTimeout(() => playBeep(600, 0.3, 0.4), 200);
                },
                setBGMVolume: (volume) => {
                    bgmAudio.volume = Math.max(0, Math.min(1, volume));
                },
                setSFXVolume: (volume) => {
                    // ÂäπÊûúÈü≥Èü≥Èáè„ÅØÂÜÖÈÉ®„ÅßÁÆ°ÁêÜÔºàWeb Audio API„ÅÆÈü≥ÈáèË™øÊï¥Ôºâ
                    // ÂÆüÈöõ„ÅÆÈü≥ÈáèË™øÊï¥„ÅØ playBeep Èñ¢Êï∞ÂÜÖ„Åß‰ΩøÁî®
                    window.sfxVolume = Math.max(0, Math.min(1, volume));
                },
                // Êñ∞„Åó„ÅÑBGM„Å´Â§âÊõ¥„Åô„ÇãÈñ¢Êï∞
                changeBGM: () => {
                    const newBGM = bgmFiles[Math.floor(Math.random() * bgmFiles.length)];
                    bgmAudio.src = newBGM;
                    return newBGM;
                },
                // BGMÂêç„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
                getCurrentBGMName: () => {
                    const fileName = bgmAudio.src.split('/').pop();
                    return fileName ? decodeURIComponent(fileName.replace('.mp3', '')) : 'Unknown';
                }
            };
        };
        /**
         * „Ç≠„É£„É©„ÇØ„Çø„ÉºÊÉÖÂ†±ÔºàÁîªÂÉè„Éï„Ç°„Ç§„É´Âêç„ÅØ images/001.png ÔΩû images/029.pngÔºâ
         */
        const CHARACTER_STATS = {
          '001': { name: "„Åò„ÇÉ„Åå", speed: 1.2, jump: 1.1, size: 1.0, color: "#D4AF37", specialty: "„É™„Éº„ÉÄ„Éº„Ç∑„ÉÉ„Éó", emoji: "üëë" },
          '002': { name: "„Åï„Åè„Çâ", speed: 1.0, jump: 1.0, size: 0.9, color: "#FFB6C1", specialty: "ÂãïÁâ©„Å®‰ºöË©±", emoji: "üå∏" },
          '003': { name: "„Éó„É™„É≥", speed: 0.8, jump: 0.9, size: 1.1, color: "#F5DEB3", specialty: "Ê≥ïÂæãÁõ∏Ë´á", emoji: "üìö" },
          '004': { name: "„Åã„Å∑„Å°„Éº„ÇÇ", speed: 1.1, jump: 1.0, size: 1.0, color: "#DEB887", specialty: "ÊñôÁêÜ", emoji: "üë®‚Äçüç≥" },
          '005': { name: "„Éè„É†Â®ò", speed: 0.9, jump: 1.0, size: 0.9, color: "#FF69B4", specialty: "ÂåªÁôÇ", emoji: "üíä" },
          '006': { name: "„Åè„Åπ„Åó", speed: 1.3, jump: 1.2, size: 1.0, color: "#32CD32", specialty: "ÂÜíÈô∫", emoji: "üó°Ô∏è" },
          '007': { name: "„É™„Éß„Éº„Çø", speed: 1.2, jump: 1.3, size: 1.1, color: "#87CEEB", specialty: "„Çπ„Éù„Éº„ÉÑ", emoji: "‚öΩ" },
          '008': { name: "„Éè„É†„Åæ„Çç", speed: 0.8, jump: 0.9, size: 1.0, color: "#F0F8FF", specialty: "Êà¶Áï•", emoji: "üß†" },
          '009': { name: "„É™„Éº„Çº„É≥„Éà‰∏∏", speed: 1.0, jump: 1.0, size: 1.0, color: "#90EE90", specialty: "ÈõÜË®à", emoji: "üìä" },
          '010': { name: "„ÇÇ„Åø„Åò", speed: 1.0, jump: 1.1, size: 0.9, color: "#FF6347", specialty: "„Ç´„Ç¶„É≥„Çª„É™„É≥„Ç∞", emoji: "üçÅ" },
          '011': { name: "„Ç¢„ÇØ„Ç¢", speed: 1.1, jump: 1.2, size: 1.0, color: "#00CED1", specialty: "„Ç®„É≥„Ç∏„Éã„Ç¢", emoji: "‚öôÔ∏è" },
          '012': { name: "„ÅÜ„Åö„Çâ", speed: 0.9, jump: 1.0, size: 1.0, color: "#DDA0DD", specialty: "„Éó„É≠„Éû„Éç", emoji: "üìã" },
          '013': { name: "„Åô„ÅÑ„ÇÅ„ÅÑ", speed: 1.1, jump: 1.4, size: 0.9, color: "#B0E0E6", specialty: "ÂøçË°ì", emoji: "ü•∑" },
          '014': { name: "„Éè„É†„Çä„Çì", speed: 1.3, jump: 1.0, size: 0.8, color: "#FFD700", specialty: "„ÇÆ„É£„É≥„Éñ„É´", emoji: "üé≤" },
          '015': { name: "„É©„ÉÉ„Ç≠„Éº", speed: 1.0, jump: 1.1, size: 1.0, color: "#DA70D6", specialty: "ÈáëÂ∫´Áï™", emoji: "üí∞" },
          '016': { name: "„Å™„Å™„ÅÑ„Çç", speed: 1.2, jump: 1.3, size: 0.8, color: "#9370DB", specialty: "Áô∫Êòé", emoji: "üî¨" },
          '017': { name: "„Åè„ÇäÂùä", speed: 0.9, jump: 1.1, size: 1.2, color: "#8B4513", specialty: "Ê†ºÈóòÊäÄ", emoji: "üëä" },
          '018': { name: "„Åø„Åü„Çâ„Åó", speed: 1.1, jump: 1.0, size: 1.0, color: "#CD853F", specialty: "‰Ωï„Åß„ÇÇÂ±ã", emoji: "üõ†Ô∏è" },
          '019': { name: "„Çø„É≥„Ç¥", speed: 1.0, jump: 1.2, size: 1.0, color: "#2F4F4F", specialty: "„ÉÑ„ÉÉ„Ç≥„Éü", emoji: "üò§" },
          '020': { name: "„Å§„ÅÑ„Å¶„Çã", speed: 1.1, jump: 1.1, size: 0.9, color: "#F0E68C", specialty: "„Ç®„É≥„Çø„É°", emoji: "üé≠" },
          '021': { name: "„Éê„ÇØ", speed: 1.2, jump: 1.4, size: 0.9, color: "#4169E1", specialty: "„Çµ„Ç§„Ç≠„ÉÉ„ÇØ", emoji: "üîÆ" },
          '022': { name: "„Åì„ÅÆ„ÅØ", speed: 1.1, jump: 1.0, size: 1.0, color: "#228B22", specialty: "‰∫∫ÁîüÁõ∏Ë´á", emoji: "üåª" },
          '023': { name: "„Åü„ÅÑ„ÅÇ„Çì", speed: 1.4, jump: 1.1, size: 1.1, color: "#FF4500", specialty: "ÈÅãËª¢", emoji: "üèéÔ∏è" },
          '024': { name: "„Éè„É†„É¨„ÉÉ„Éà", speed: 1.2, jump: 1.2, size: 1.0, color: "#483D8B", specialty: "„Éí„Éº„É≠„Éº", emoji: "ü¶∏" },
          '025': { name: "„ÇØ„É™„Ç™„Éç„Ç¢", speed: 1.3, jump: 1.0, size: 0.8, color: "#87CEFA", specialty: "ÂÆ¥‰ºöÈÉ®Èï∑", emoji: "üéâ" },
          '026': { name: "„ÇÄ„Çâ„ÇÄ„Åô„ÇÅ", speed: 1.2, jump: 1.1, size: 1.0, color: "#FF1493", specialty: "„ÇÆ„É£„É´", emoji: "üíÖ" },
          '027': { name: "„ÅÇ„Çì„Åø„Å§Âß´", speed: 0.9, jump: 1.0, size: 1.0, color: "#DDA0DD", specialty: "„ÅäÂ¨¢Êßò", emoji: "üë∏" },
          '028': { name: "„Åπ„Å´„Åü„Çì", speed: 1.0, jump: 1.1, size: 1.0, color: "#DC143C", specialty: "Ëä∏Ë°ìÂÆ∂", emoji: "üé®" },
          '029': { name: "„ÇÇ„Å™„Å°„ÇÉ„Çì", speed: 1.0, jump: 1.2, size: 0.9, color: "#708090", specialty: "ÊòüÂç†„ÅÑ", emoji: "‚≠ê" }
        };
        
        const SlimeSoccerMobile = () => {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const lastFrameTimeRef = useRef(0);
            
            // Game state
            const [gameMode, setGameMode] = useState(null);
            const [timeLeft, setTimeLeft] = useState(0);
            const [score, setScore] = useState({ left: 0, right: 0 });
            const [gameStarted, setGameStarted] = useState(false);
            const [winner, setWinner] = useState(null);
            
            // ËÉåÊôØÁîªÂÉè„ÅÆÁä∂ÊÖã„ÇíËøΩÂä†
            const [backgroundImage, setBackgroundImage] = useState(null);
            const backgroundImages = [
                'images/h1.png', 'images/h2.png', 'images/h3.png', 'images/h4.png', 
                'images/h5.jpg', 'images/h6.png', 'images/h7.png', 'images/h8.png',
                'images/h9.png', 'images/h10.png', 'images/h11.png', 'images/h12.png', 'images/h13.png'
            ];
            
            // BGM„Å®ÂäπÊûúÈü≥„ÅÆÁÆ°ÁêÜ
            const audioManagerRef = useRef(null);
            const [musicEnabled, setMusicEnabled] = useState(false);
            const [bgmVolume, setBgmVolume] = useState(0.6);
            const [sfxVolume, setSfxVolume] = useState(0.8);
            
            // Èü≥Ê•Ω„ÅÆÂàùÊúüÂåñ
            useEffect(() => {
                if (!audioManagerRef.current) {
                    audioManagerRef.current = createAudioManager();
                }
            }, []);
            
            // Game objects state
            const gameStateRef = useRef({
                leftSlime: {
                    x: 200,
                    y: GAME_HEIGHT - GROUND_HEIGHT,
                    vx: 0,
                    vy: 0,
                    goalLineTime: 0,
                    targetX: 200,
                    lastDecisionTime: 0,
                    decisionCooldown: 0,
                    stableStart: true
                },
                rightSlime: {
                    x: 600,
                    y: GAME_HEIGHT - GROUND_HEIGHT,
                    vx: 0,
                    vy: 0,
                    goalLineTime: 0
                },
                ball: {
                    x: GAME_WIDTH / 2,
                    y: 150,
                    vx: 0,
                    vy: 0,
                    grabbedBy: null,
                    grabAngle: 0,
                    grabAngularVelocity: 0
                }
            });
            
            // SlimeSoccerMobile„ÅÆstate„Å´playerCharId, aiCharId, stepÔºàÁîªÈù¢ÈÅ∑ÁßªÁî®Ôºâ„ÇíËøΩÂä†
            const [playerCharId, setPlayerCharId] = useState(null);
            const [aiCharId, setAiCharId] = useState(null);
            const [step, setStep] = useState(0); // 0: „É°„Éã„É•„Éº, 1: Èõ£ÊòìÂ∫¶ÈÅ∏Êäû, 2: Ë©¶ÂêàÊôÇÈñìÈÅ∏Êäû, 3: „Ç≤„Éº„É†
            
            // „Ç≠„É£„É©„ÇØ„Çø„ÉºÈÅ∏ÊäûÁîªÈù¢„ÅÆUI„ÇíËøΩÂä†
            const [selectedCharacter, setSelectedCharacter] = useState(null);

            // „É°„Éã„É•„Éº/„Ç≤„Éº„É†ÊôÇ„ÅÆbody„Çπ„Çø„Ç§„É´Âàá„ÇäÊõø„Åà
            useEffect(() => {
                if (step === 3 || gameStarted) {
                    document.body.style.touchAction = 'none';
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.touchAction = 'auto';
                    document.body.style.overflow = 'auto';
                }
            }, [step, gameStarted]);

            // Timer
            useEffect(() => {
                if (gameStarted && timeLeft > 0) {
                    const timer = setInterval(() => {
                        setTimeLeft(prev => {
                            if (prev <= 1) {
                                setGameStarted(false);
                                determineWinner();
                                return 0;
                            // „Éú„Éº„É´„Å®„Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÊé•Ëß¶ÊôÇ„Å´ÂäπÊûúÈü≥Ôºà„Ç∑„É≥„Éó„É´„Å™ÈõªÂ≠êÈü≥Ôºâ
                        if (musicEnabled && audioManagerRef.current && window.sfxVolume > 0) {
                            audioManagerRef.current.playKick();
                        }
                            return prev - 1;
                        });
                    }, 1000);
                    
                    return () => clearInterval(timer);
                }
            }, [gameStarted, timeLeft]);
            
            const determineWinner = () => {
                if (score.left > score.right) {
                    setWinner('Èùí„ÉÅ„Éº„É†');
                } else if (score.right > score.left) {
                    setWinner('Ëµ§„ÉÅ„Éº„É†');
                } else {
                    setWinner('Âºï„ÅçÂàÜ„Åë');
                }
            };
            
            // „Çπ„É©„Ç§„É†ÂàùÊúüÂåñ„Éª„É™„Çª„ÉÉ„ÉàÊôÇ„ÅÆyÂ∫ßÊ®ô„Çí‰∏≠ÂøÉÂü∫Ê∫ñ„Å´‰øÆÊ≠£
            const resetPositions = () => {
                const state = gameStateRef.current;
                const leftRadius = getSlimeRadius(aiCharId);
                const rightRadius = getSlimeRadius(playerCharId);
                state.leftSlime.x = 200;
                state.leftSlime.y = (GAME_HEIGHT - GROUND_HEIGHT) - leftRadius; // ‰∏≠ÂøÉy
                state.leftSlime.vx = 0;
                state.leftSlime.vy = 0;
                state.leftSlime.goalLineTime = 0;
                state.leftSlime.targetX = 200;
                state.leftSlime.lastDecisionTime = 0;
                state.leftSlime.decisionCooldown = 0;
                state.leftSlime.stableStart = true;

                state.rightSlime.x = 600;
                state.rightSlime.y = (GAME_HEIGHT - GROUND_HEIGHT) - rightRadius; // ‰∏≠ÂøÉy
                state.rightSlime.vx = 0;
                state.rightSlime.vy = 0;
                state.rightSlime.goalLineTime = 0;

                state.ball.x = GAME_WIDTH / 2;
                state.ball.y = 150;
                state.ball.vx = 0;
                state.ball.vy = 0;
                state.ball.grabbedBy = null;
                state.ball.grabAngle = 0;
                state.ball.grabAngularVelocity = 0;
            };
            
            const resetGame = () => {
                resetPositions();
                setScore({ left: 0, right: 0 });
                setWinner(null);
                // „Ç≤„Éº„É†ÈñãÂßãÊôÇ„Å´ËÉåÊôØ„Çí„É©„É≥„ÉÄ„É†ÈÅ∏Êäû
                const randomIndex = Math.floor(Math.random() * backgroundImages.length);
                setBackgroundImage(backgroundImages[randomIndex]);
                
                // BGMÈñãÂßã
                if (musicEnabled && audioManagerRef.current) {
                    audioManagerRef.current.playBGM();
                }
            };
            
            // „Ç≤„Éº„É†Êú¨‰Ωì„ÅÆ„Ç≠„É£„É©ËÉΩÂäõ„ÉªAIÈõ£ÊòìÂ∫¶ÂèçÊò†Áî®„Éò„É´„Éë„Éº
            const getCharStats = (id) => CHARACTER_STATS[id] || { speed: 1, jump: 1, size: 1, color: '#888', name: '', emoji: '' };
            
            // AIË°åÂãï„Çø„Ç§„Éû„Éº
            const aiLastUpdateRef = useRef(0);

            // updateAI: AI„Ç≠„É£„É©„ÅÆËÉΩÂäõÂÄ§„ÉªÈõ£ÊòìÂ∫¶ÂèçÊò†
            const updateAI = useCallback((currentTime) => {
                if (!aiCharId) return;
                const state = gameStateRef.current;
                const ai = state.leftSlime;
                const ball = state.ball;
                const stats = getCharStats(aiCharId);
                const aiDelay = window.aiDifficulty?.delay ?? 200;
                if (currentTime - aiLastUpdateRef.current < aiDelay) return;
                aiLastUpdateRef.current = currentTime;
                // AI: „Éú„Éº„É´„ÇíËøΩ„ÅÑ„Åã„Åë„Çã
                if (ball.x < ai.x - 20) {
                    ai.vx = -SLIME_SPEED * stats.speed;
                } else if (ball.x > ai.x + 20) {
                    ai.vx = SLIME_SPEED * stats.speed;
                } else {
                    ai.vx = 0;
                }
                // „Ç∏„É£„É≥„ÉóÔºàÊù°‰ª∂„Çí-100„Å´Ë™øÊï¥„Åó„Å¶ÈÅéÂâ∞„Ç∏„É£„É≥„ÉóÈò≤Ê≠¢Ôºâ
                if (ball.y < ai.y - 100 && Math.abs(ball.x - ai.x) < 100 && ai.vy === 0) {
                    ai.vy = SLIME_JUMP_POWER * stats.jump;
                }
            }, [aiCharId]);

            // „Çπ„É©„Ç§„É†„ÅÆÂú∞Èù¢‰ΩçÁΩÆË®àÁÆóÁî®„Éò„É´„Éë„Éº
            const getSlimeRadius = (charId) => SLIME_RADIUS * Math.max(0.85, getCharStats(charId).size) * 1.4;
            // Âú∞Èù¢„ÅÆYÂ∫ßÊ®ô
            const groundY = GAME_HEIGHT - GROUND_HEIGHT;

            // --- „Ç∑„É≥„Ç∞„É´„Éó„É¨„Ç§Áî®„Çø„ÉÉ„ÉÅ„Éª„Éú„Çø„É≥Êìç‰Ωú„Éè„É≥„Éâ„É© ---
            // „Éó„É¨„Ç§„É§„ÉºÊìç‰ΩúÁä∂ÊÖã
            const playerControlRef = useRef({ vx: 0, jump: false });
            // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÁä∂ÊÖã
            const joystickRef = useRef({ active: false, centerX: 0, centerY: 0, currentX: 0, currentY: 0, radius: 50 });
            // „Ç≠„Éº„Ç§„Éô„É≥„Éà
            useEffect(() => {
                const down = (e) => {
                    if (e.repeat) return;
                    if (e.key === 'ArrowLeft') playerControlRef.current.vx = -SLIME_SPEED;
                    if (e.key === 'ArrowRight') playerControlRef.current.vx = SLIME_SPEED;
                    if (e.key === ' ' || e.key === 'ArrowUp') playerControlRef.current.jump = true;
                };
                const up = (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') playerControlRef.current.vx = 0;
                    if (e.key === ' ' || e.key === 'ArrowUp') playerControlRef.current.jump = false;
                };
                window.addEventListener('keydown', down);
                window.addEventListener('keyup', up);
                return () => {
                    window.removeEventListener('keydown', down);
                    window.removeEventListener('keyup', up);
                };
            }, []);

            // --- ‰ªÆÊÉ≥„Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„Å®„Çø„ÉÉ„ÉÅ„Ç∏„É£„É≥„Éó„Ç§„Éô„É≥„Éà ---
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                let joystickTouchId = -1; // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÂ∞ÇÁî®„Çø„ÉÉ„ÉÅID
                let jumpActive = false;
                const scaleX = GAME_WIDTH / canvas.clientWidth;
                const scaleY = GAME_HEIGHT / canvas.clientHeight;
                const handleTouchStart = (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        const x = touch.clientX * scaleX;
                        const y = touch.clientY * scaleY;
                        if (joystickTouchId === -1 && x < GAME_WIDTH / 2 && y > GAME_HEIGHT / 2) {
                            // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÊ¥ªÊÄßÂåñ
                            joystickTouchId = touch.identifier;
                            joystickRef.current.active = true;
                            joystickRef.current.centerX = x;
                            joystickRef.current.centerY = y;
                            joystickRef.current.currentX = x;
                            joystickRef.current.currentY = y;
                        } else {
                            // Âè≥ÂÅ¥ÈôêÂÆö„Åß„Ç∏„É£„É≥„Éó
                            if (x > GAME_WIDTH / 2) {
                                jumpActive = true;
                                playerControlRef.current.jump = true;
                            }
                        }
                    }
                };
                const handleTouchMove = (e) => {
                    e.preventDefault();
                    for (let touch of e.touches) {
                        if (touch.identifier === joystickTouchId) {
                            const x = touch.clientX * scaleX;
                            const y = touch.clientY * scaleY;
                            const dx = x - joystickRef.current.centerX;
                            const dy = y - joystickRef.current.centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const maxDist = joystickRef.current.radius;
                            if (dist > maxDist) {
                                const angle = Math.atan2(dy, dx);
                                joystickRef.current.currentX = joystickRef.current.centerX + Math.cos(angle) * maxDist;
                                joystickRef.current.currentY = joystickRef.current.centerY + Math.sin(angle) * maxDist;
                            } else {
                                joystickRef.current.currentX = x;
                                joystickRef.current.currentY = y;
                            }
                            // vxÊõ¥Êñ∞ (Ê∞¥Âπ≥ÁßªÂãï„ÅÆ„Åø)
                            playerControlRef.current.vx = (dx / maxDist) * SLIME_SPEED * getCharStats(playerCharId).speed;
                        }
                    }
                };
                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        if (touch.identifier === joystickTouchId) {
                            joystickTouchId = -1;
                            joystickRef.current.active = false;
                            playerControlRef.current.vx = 0;
                        } else {
                            jumpActive = false;
                            playerControlRef.current.jump = false;
                        }
                    }
                };
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                return () => {
                    canvas.removeEventListener('touchstart', handleTouchStart);
                    canvas.removeEventListener('touchmove', handleTouchMove);
                    canvas.removeEventListener('touchend', handleTouchEnd);
                };
            }, [gameStarted, playerCharId]);

            // updatePhysics: „Éú„Éº„É´„ÅåÂøÖ„Åö‰∏äÊñπÂêë„Å´Âºæ„Åã„Çå„Çã„Çà„ÅÜ„Å´‰øÆÊ≠£
            const updatePhysics = useCallback((currentTime) => {
                const state = gameStateRef.current;
                const playerStats = getCharStats(playerCharId);
                state.rightSlime.vx = playerControlRef.current.vx;
                // „Ç∏„É£„É≥„ÉóÂà§ÂÆö
                const rightSlimeRadius = getSlimeRadius(playerCharId);
                if (playerControlRef.current.jump && state.rightSlime.y + rightSlimeRadius >= groundY - 1) {
                    state.rightSlime.vy = SLIME_JUMP_POWER * playerStats.jump;
                    playerControlRef.current.jump = false;
                }
                updateAI(currentTime);
                [state.leftSlime, state.rightSlime].forEach((slime, idx) => {
                    const charId = idx === 0 ? aiCharId : playerCharId;
                    const slimeRadius = getSlimeRadius(charId);
                    slime.vy += GRAVITY;
                    slime.x += slime.vx;
                    slime.y += slime.vy;
                    if (slime.x < slimeRadius) slime.x = slimeRadius;
                    if (slime.x > GAME_WIDTH - slimeRadius) slime.x = GAME_WIDTH - slimeRadius;
                    // Âú∞Èù¢Âà§ÂÆöÔºàÂçäÂÜÜ‰∏≠ÂøÉÂü∫Ê∫ñÔºâ
                    if (slime.y + slimeRadius > groundY) {
                        slime.y = groundY - slimeRadius;
                        slime.vy = 0;
                    }
                });
                // „Éú„Éº„É´Áâ©ÁêÜ
                if (state.ball.grabbedBy) {
                    // „Ç∞„É©„ÉñÊ©üËÉΩ„ÅØÂâäÈô§Ê∏à„Åø
                } else {
                    state.ball.vy += GRAVITY;
                    state.ball.vx *= BALL_DAMPING;
                    state.ball.x += state.ball.vx;
                    state.ball.y += state.ball.vy;
                }
                // „Éú„Éº„É´„ÅÆÂ£Å„ÉªÂ§©‰∫ï„ÉªÂú∞Èù¢ÂèçÁô∫
                if (state.ball.x < BALL_RADIUS) {
                    state.ball.x = BALL_RADIUS;
                    state.ball.vx = -state.ball.vx * BALL_BOUNCE_DAMPING;
                }
                if (state.ball.x > GAME_WIDTH - BALL_RADIUS) {
                    state.ball.x = GAME_WIDTH - BALL_RADIUS;
                    state.ball.vx = -state.ball.vx * BALL_BOUNCE_DAMPING;
                }
                if (state.ball.y > groundY - BALL_RADIUS) {
                    state.ball.y = groundY - BALL_RADIUS;
                    state.ball.vy = -state.ball.vy * BALL_BOUNCE_DAMPING;
                }
                if (state.ball.y < BALL_RADIUS) {
                    state.ball.y = BALL_RADIUS;
                    state.ball.vy = -state.ball.vy * BALL_BOUNCE_DAMPING;
                }
                // „Éú„Éº„É´„Å®„Çπ„É©„Ç§„É†„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö - „Çµ„ÉÉ„Ç´„Éº„ÅÆ„ÇØ„É™„Ç¢Ê©üËÉΩ‰ªò„Åç
                [state.leftSlime, state.rightSlime].forEach((slime, idx) => {
                    const charId = idx === 0 ? aiCharId : playerCharId;
                    const slimeRadius = getSlimeRadius(charId);
                    // „Çπ„É©„Ç§„É†„ÅÆ‰∏≠ÂøÉÂ∫ßÊ®ô = (slime.x, slime.y)
                    const slimeCx = slime.x;
                    const slimeCy = slime.y;
                    const dx = state.ball.x - slimeCx;
                    const dy = state.ball.y - slimeCy;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < slimeRadius + BALL_RADIUS) {
                        // Ëá™ÁÑ∂„Å™ÂèçÁô∫ËßíÂ∫¶„ÇíË®àÁÆó
                        let angle = Math.atan2(dy, dx);
                        
                        // „Éú„Éº„É´„ÅåÂú∞Èù¢Ëøë„Åè„Å´„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà„ÇØ„É™„Ç¢Âà§ÂÆöÔºâ
                        const ballDistanceFromGround = groundY - BALL_RADIUS - state.ball.y;
                        const isBallNearGround = ballDistanceFromGround <= 30; // Âú∞Èù¢„Åã„Çâ30„Éî„ÇØ„Çª„É´‰ª•ÂÜÖ
                        
                        if (isBallNearGround) {
                            // „Çµ„ÉÉ„Ç´„Éº„ÅÆ„ÇØ„É™„Ç¢„ÅÆ„Çà„ÅÜ„Å™Âãï‰Ωú
                            console.log('Ground ball clear!'); // „Éá„Éê„ÉÉ„Ç∞Áî®
                            
                            // Ê®™ÊñπÂêë„ÅÆÊàêÂàÜ„ÅØ‰øùÊåÅ„Åó„Å§„Å§„ÄÅ‰∏äÊñπÂêë„ÇíÂº∑Âåñ
                            const horizontalDirection = dx > 0 ? 1 : -1;
                            
                            // „ÇØ„É™„Ç¢ÊôÇ„ÅÆËßíÂ∫¶Ôºà30Â∫¶„Äú60Â∫¶„ÅÆÁØÑÂõ≤„Åß‰∏äÂêë„ÅçÔºâ
                            const clearAngleMin = -Math.PI / 3; // -60Â∫¶
                            const clearAngleMax = -Math.PI / 6; // -30Â∫¶
                            
                            if (horizontalDirection > 0) {
                                // Âè≥ÊñπÂêë„ÅÆ„ÇØ„É™„Ç¢
                                angle = clearAngleMin + (clearAngleMax - clearAngleMin) * 0.7; // „ÇÑ„ÇÑÂè≥‰∏ä
                            } else {
                                // Â∑¶ÊñπÂêë„ÅÆ„ÇØ„É™„Ç¢
                                angle = Math.PI + clearAngleMin + (clearAngleMax - clearAngleMin) * 0.3; // „ÇÑ„ÇÑÂ∑¶‰∏ä
                            }
                        } else {
                            // ÈÄöÂ∏∏„ÅÆÁ©∫‰∏≠„Åß„ÅÆ„Éú„Éº„É´Ôºö„Çπ„É©„Ç§„É†„ÅÆ‰∏ãÂçäÂàÜ„Å´ÂΩì„Åü„Å£„ÅüÂ†¥Âêà„ÅÆ„ÅøËªΩ„ÅÑË£úÊ≠£
                            const slimeGroundY = slime.y + slimeRadius;
                            const ballRelativeY = state.ball.y - slimeGroundY;
                            
                            if (ballRelativeY > -slimeRadius * 0.3) {
                                // „Éú„Éº„É´„Åå„Çπ„É©„Ç§„É†„ÅÆ‰∏ãÈÉ®30%„Å´ÂΩì„Åü„Å£„ÅüÂ†¥Âêà„ÄÅËªΩ„Åè‰∏äÂêë„Åç„Å´Ë£úÊ≠£
                                if (angle > Math.PI * 0.4) {
                                    angle = Math.PI * 0.4; // 72Â∫¶Ôºà„ÇÑ„ÇÑ‰∏äÂêë„ÅçÔºâ
                                } else if (angle < -Math.PI * 0.4) {
                                    angle = -Math.PI * 0.4; // -72Â∫¶Ôºà„ÇÑ„ÇÑ‰∏äÂêë„ÅçÔºâ
                                }
                            }
                        }
                        
                        // „Éú„Éº„É´„ÅÆÊñ∞„Åó„ÅÑ‰ΩçÁΩÆ„ÇíË®≠ÂÆö
                        const targetX = slimeCx + Math.cos(angle) * (slimeRadius + BALL_RADIUS);
                        const targetY = slimeCy + Math.sin(angle) * (slimeRadius + BALL_RADIUS);
                        state.ball.x = targetX;
                        state.ball.y = targetY;
                        
                        // ÈÄüÂ∫¶Ë®àÁÆó
                        const currentSpeed = Math.sqrt(state.ball.vx * state.ball.vx + state.ball.vy * state.ball.vy);
                        let baseSpeed;
                        
                        if (isBallNearGround) {
                            // „ÇØ„É™„Ç¢ÊôÇ„ÅØÂº∑„ÇÅ„ÅÆÂäõ„ÇíÈÅ©Áî®
                            baseSpeed = Math.max(currentSpeed * 1.2, 10);
                            
                            // „ÇØ„É™„Ç¢ÊôÇ„ÅÆÂèçÁô∫Âäõ
                            const clearPower = 1.6;
                            state.ball.vx = Math.cos(angle) * baseSpeed * clearPower + slime.vx * 0.5;
                            state.ball.vy = Math.sin(angle) * baseSpeed * clearPower + slime.vy * 0.5;
                            
                            // „ÇØ„É™„Ç¢ÊôÇ„ÅØÂøÖ„Åö‰∏äÂêë„Åç„ÅÆÂäõ„Çí‰øùË®º
                            if (state.ball.vy > -5) {
                                state.ball.vy = -8; // Âº∑Âà∂ÁöÑ„Å´‰∏äÂêë„Åç„Å´
                            }
                        } else {
                            // ÈÄöÂ∏∏„ÅÆÁ©∫‰∏≠„Åß„ÅÆÂèçÁô∫
                            baseSpeed = Math.max(currentSpeed * 0.8, 6);
                            
                            const reflectionPower = 1.3;
                            state.ball.vx = Math.cos(angle) * baseSpeed * reflectionPower + slime.vx * 0.4;
                            state.ball.vy = Math.sin(angle) * baseSpeed * reflectionPower + slime.vy * 0.4;
                            
                            // Âú∞Èù¢Ëøë„Åè„Åß„ÅÆÂΩì„Åü„Çä„ÅÆÂ†¥Âêà„ÅÆ„Åø„ÄÅ„Çè„Åö„Åã„Å´‰∏äÂêë„ÅçÊàêÂàÜ„ÇíËøΩÂä†
                            const slimeGroundY = slime.y + slimeRadius;
                            const ballRelativeY = state.ball.y - slimeGroundY;
                            if (ballRelativeY > -slimeRadius * 0.2 && state.ball.vy > -2) {
                                state.ball.vy -= 3; // ËªΩ„Åè‰∏äÂêë„Åç„ÅÆÂäõ„ÇíËøΩÂä†
                            }
                        }
                        
                        // ÊúÄÂ§ßÈÄüÂ∫¶Âà∂Èôê
                        const newSpeed = Math.sqrt(state.ball.vx * state.ball.vx + state.ball.vy * state.ball.vy);
                        if (newSpeed > MAX_BALL_SPEED) {
                            const scale = MAX_BALL_SPEED / newSpeed;
                            state.ball.vx *= scale;
                            state.ball.vy *= scale;
                        }
                    }
                });
                
                // Goal detection
                if (state.ball.x <= BALL_RADIUS && state.ball.y > groundY - GOAL_HEIGHT) {
                    setScore(prev => ({ ...prev, right: prev.right + 1 }));
                    // „Ç¥„Éº„É´ÂäπÊûúÈü≥Ôºà„Ç∑„É≥„Éó„É´„Å™ÈõªÂ≠êÈü≥Ôºâ
                    if (musicEnabled && audioManagerRef.current && window.sfxVolume > 0) {
                        audioManagerRef.current.playGoal();
                    }
                    resetPositions();
                } else if (state.ball.x >= GAME_WIDTH - BALL_RADIUS && state.ball.y > groundY - GOAL_HEIGHT) {
                    setScore(prev => ({ ...prev, left: prev.left + 1 }));
                    // „Ç¥„Éº„É´ÂäπÊûúÈü≥Ôºà„Ç∑„É≥„Éó„É´„Å™ÈõªÂ≠êÈü≥Ôºâ
                    if (musicEnabled && audioManagerRef.current && window.sfxVolume > 0) {
                        audioManagerRef.current.playGoal();
                    }
                    resetPositions();
                }
                // Ceiling collision
                if (state.ball.y < BALL_RADIUS) {
                    state.ball.y = BALL_RADIUS;
                    state.ball.vy = -state.ball.vy * BALL_BOUNCE_DAMPING;
                }
            }, [playerCharId, aiCharId, updateAI]);
            
            // draw: ËÉåÊôØÁîªÂÉè‰ªò„Åç„ÅÆÊèèÁîª
            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const state = gameStateRef.current;
                
                // ËÉåÊôØÁîªÂÉè„ÇíÊèèÁîªÔºà„ÅÇ„Çå„Å∞Ôºâ
                if (backgroundImage) {
                    const bgImg = new window.Image();
                    bgImg.src = backgroundImage;
                    if (bgImg.complete && bgImg.naturalWidth > 0) {
                        // ËÉåÊôØÁîªÂÉè„Çí„Ç≠„É£„É≥„Éê„ÇπÂÖ®‰Ωì„Å´Êã°Â§ß„Åó„Å¶ÊèèÁîª
                        ctx.drawImage(bgImg, 0, 0, GAME_WIDTH, GAME_HEIGHT);
                    } else {
                        // ÁîªÂÉè„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÂæìÊù•„ÅÆÈùíËÉåÊôØ
                        ctx.fillStyle = '#0066ff';
                        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                        // ÁîªÂÉèË™≠„ÅøËæº„ÅøÂÆå‰∫ÜÊôÇ„Å´ÂÜçÊèèÁîª
                        if (!bgImg.complete) {
                            bgImg.onload = () => draw();
                        }
                    }
                } else {
                    // ËÉåÊôØÁîªÂÉè„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÂæìÊù•„ÅÆÈùíËÉåÊôØ
                    ctx.fillStyle = '#0066ff';
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                }
                
                // Âú∞Èù¢ÔºàËÉåÊôØ„ÅÆ‰∏ä„Å´ÂçäÈÄèÊòé„ÅßÊèèÁîªÔºâ
                ctx.fillStyle = 'rgba(128, 128, 128, 0.8)';
                ctx.fillRect(0, GAME_HEIGHT - GROUND_HEIGHT, GAME_WIDTH, GROUND_HEIGHT);
                
                // --- „Ç¥„Éº„É´„Ç®„É™„Ç¢Ëâ≤ÂàÜ„Åë ---
                ctx.save();
                // Â∑¶„Ç¥„Éº„É´ÔºàÈùíÔºâ
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#00BFFF';
                ctx.fillRect(0, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT, GOAL_WIDTH, GOAL_HEIGHT);
                // Âè≥„Ç¥„Éº„É´ÔºàËµ§Ôºâ
                ctx.fillStyle = '#FF6347';
                ctx.fillRect(GAME_WIDTH - GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT, GOAL_WIDTH, GOAL_HEIGHT);
                ctx.globalAlpha = 1.0;
                ctx.restore();
                
                // --- Êó¢Â≠ò„ÅÆ„Ç¥„Éº„É´Êû†Á∑ö ---
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                // Â∑¶„Ç¥„Éº„É´
                ctx.beginPath();
                ctx.moveTo(0, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.moveTo(GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
                ctx.stroke();
                // Âè≥„Ç¥„Éº„É´
                ctx.beginPath();
                ctx.moveTo(GAME_WIDTH - GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GAME_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.moveTo(GAME_WIDTH - GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GAME_WIDTH - GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
                ctx.stroke();
                
                // „Çπ„É©„Ç§„É†ÊèèÁîª
                const drawSlime = (slime, charId, isAI) => {
                    const stats = getCharStats(charId);
                    // ÂçäÂÜÜ„ÅÆÁâ©ÁêÜÂà§ÂÆöÁî®„Éë„É©„É°„Éº„Çø
                    const slimeRadius = getSlimeRadius(charId);
                    // --- ÈÄèÊòé„Å™ÂçäÂÜÜÔºàÂΩì„Åü„ÇäÂà§ÂÆöÁî®„ÄÅË¶ã„ÅüÁõÆ„Å´„ÅØË°®Á§∫„Åó„Å™„ÅÑÔºâ---
                    ctx.save();
                    ctx.globalAlpha = 0; // ÂÆåÂÖ®„Å´ÈÄèÊòé
                    ctx.beginPath();
                    ctx.arc(slime.x, slime.y, slimeRadius, Math.PI, 0); // y„Çíslime.y„Å´‰øÆÊ≠£
                    ctx.closePath();
                    ctx.fillStyle = stats.color;
                    ctx.fill();
                    ctx.restore();
                    // --- „Ç≠„É£„É©ÁîªÂÉè„ÅÆ‰∏ãÁ´Ø‰∏≠Â§Æ„ÇíÂú∞Èù¢„Å´ÊèÉ„Åà„Å¶ÊèèÁîª ---
                    const img = new window.Image();
                    img.src = `images/${charId}.png`;
                    // ÁîªÂÉè„ÅåÊú™„É≠„Éº„Éâ„ÅÆÂ†¥Âêà„ÅØonload„ÅßÂÜçÊèèÁîªÔºà„É´„Éº„ÉóÈò≤Ê≠¢„ÅÆ„Åü„ÇÅstateÁÆ°ÁêÜÊé®Â•®„Å†„ÅåÁ∞°ÊòìÁöÑ„Å´Ôºâ
                    if (!img.complete) {
                        img.onload = () => draw();
                    }
                    // ÁîªÂÉè„Çµ„Ç§„Ç∫ÂèñÂæó
                    const scale = 0.5; // ÁîªÂÉè„ÇíÂçäÂàÜ„Å´Á∏ÆÂ∞è
                    const imgWidth = (img.width || 300) * scale;
                    const imgHeight = (img.height || 300) * scale;
                    const imageY = (slime.y + slimeRadius) - imgHeight;
                    ctx.drawImage(
                        img,
                        slime.x - imgWidth / 2,
                        imageY,
                        imgWidth,
                        imgHeight
                    );
                    // --- „Ç≠„É£„É©Âêç„Éªemoji„ÇÇÁîªÂÉè„ÅÆ‰∏ä„Å´ÈÄ£Âãï ---
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    // ËÉåÊôØÁîªÂÉè„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊñáÂ≠ó„ÇíË¶ã„ÇÑ„Åô„Åè„Åô„Çã„Åü„ÇÅÂΩ±‰ªò„Åç
                    if (backgroundImage) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.strokeText(`${stats.emoji} ${stats.name}`, slime.x, imageY - 10);
                    }
                    ctx.fillStyle = isAI ? '#FFD700' : '#fff';
                    ctx.fillText(`${stats.emoji} ${stats.name}`, slime.x, imageY - 10);
                };
                drawSlime(state.leftSlime, aiCharId, true);
                drawSlime(state.rightSlime, playerCharId, false);
                
                // „Éú„Éº„É´ÔºàËÉåÊôØÁîªÂÉè„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂΩ±‰ªò„ÅçÔºâ
                if (backgroundImage) {
                    // „Éú„Éº„É´„ÅÆÂΩ±
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(state.ball.x + 2, state.ball.y + 2, BALL_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(state.ball.x, state.ball.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                
                // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÊèèÁîª
                if (joystickRef.current.active) {
                    // Â§ñÂÜÜ
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(joystickRef.current.centerX, joystickRef.current.centerY, joystickRef.current.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    // ÂÜÖ„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ
                    ctx.fillStyle = 'rgba(0, 102, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(joystickRef.current.currentX, joystickRef.current.currentY, 20, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }, [playerCharId, aiCharId, backgroundImage]);
            
            // „Ç≤„Éº„É†„É´„Éº„Éó„ÅßupdatePhysics, draw„Å´currentTime„ÇíÊ∏°„Åô
            const gameLoop = useCallback((currentTime) => {
                if (gameStarted) {
                    const targetFrameTime = 1000 / 60;
                    if (currentTime - lastFrameTimeRef.current >= targetFrameTime) {
                        updatePhysics(currentTime);
                        draw();
                        lastFrameTimeRef.current = currentTime;
                    }
                    animationRef.current = requestAnimationFrame(gameLoop);
                }
            }, [gameStarted, updatePhysics, draw]);
            
            useEffect(() => {
                if (gameStarted) {
                    animationRef.current = requestAnimationFrame(gameLoop);
                }
                
                return () => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [gameStarted, gameLoop]);
            
            // „Ç≤„Éº„É†ÁµÇ‰∫ÜÊôÇ„Å´BGMÂÅúÊ≠¢
            useEffect(() => {
                if (!gameStarted && audioManagerRef.current) {
                    audioManagerRef.current.stopBGM();
                }
            }, [gameStarted]);
            
            // Èü≥Ê•ΩON/OFFÂàá„ÇäÊõø„Åà
            const toggleMusic = () => {
                setMusicEnabled(!musicEnabled);
                if (!musicEnabled && gameStarted && audioManagerRef.current) {
                    // Èü≥Ê•Ω„ÇíON„Å´„Åó„Å¶„Ç≤„Éº„É†‰∏≠„ÅÆÂ†¥Âêà„ÅØBGMÈñãÂßã
                    audioManagerRef.current.playBGM();
                } else if (musicEnabled && audioManagerRef.current) {
                    // Èü≥Ê•Ω„ÇíOFF„Å´„Åô„ÇãÂ†¥Âêà„ÅØBGMÂÅúÊ≠¢
                    audioManagerRef.current.stopBGM();
                }
            };
            
            // Èü≥ÈáèË™øÊï¥
            useEffect(() => {
                if (audioManagerRef.current) {
                    audioManagerRef.current.setBGMVolume(bgmVolume);
                    audioManagerRef.current.setSFXVolume(sfxVolume);
                }
                // „Ç∞„É≠„Éº„Éê„É´„Å´ÂäπÊûúÈü≥Èü≥Èáè„Çí‰øùÂ≠ò
                window.sfxVolume = sfxVolume;
            }, [bgmVolume, sfxVolume]);

            // ÂÖ®ÁîªÈù¢Ë°®Á§∫„Çí„Éà„É™„Ç¨„Éº„Åô„ÇãÈñ¢Êï∞ (Ê©üÁ®Æ„Åî„Å®ÊüîËªüÂØæÂøú)
            const enterFullscreen = () => {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log('Fullscreen error:', err));
                } else if (elem.webkitRequestFullscreen) { // iOS SafariÂØæÂøú
                    elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT).catch(err => console.log('Fullscreen error:', err));
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen().catch(err => console.log('Fullscreen error:', err));
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen().catch(err => console.log('Fullscreen error:', err));
                }
            };

            // „É°„Éã„É•„Éº/„Ç≤„Éº„É†ÈñãÂßãÊôÇ„Å´ÂÖ®ÁîªÈù¢„Çí„É™„ÇØ„Ç®„Çπ„Éà („Çø„ÉÉ„Éó„Åß„Éà„É™„Ç¨„Éº)
            useEffect(() => {
                const handleTap = () => {
                    if (!document.fullscreenElement) {
                        enterFullscreen();
                    }
                };
                document.addEventListener('touchstart', handleTap, { once: true }); // ÂàùÂõû„Çø„ÉÉ„Éó„ÅßÁô∫Âãï
                return () => document.removeEventListener('touchstart', handleTap);
            }, []);

            return (
                <div className="game-container">
                    {/* „Ç≠„É£„É©„ÇØ„Çø„ÉºÈÅ∏ÊäûÁîªÈù¢ */}
                    {step === 0 && (
                        <div className="menu-container">
                            <h1>„Åò„ÇÉ„Åå„Çä„Çì„Çπ„É©„Ç§„É†„Çµ„ÉÉ„Ç´„Éº</h1>
                            <h2>„Ç≠„É£„É©„ÇØ„Çø„Éº„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</h2>
                            
                            {/* Èü≥Ê•ΩON/OFF„Éú„Çø„É≥„Å®Èü≥ÈáèË™øÊï¥ */}
                            <div style={{ marginBottom: '20px', textAlign: 'center' }}>
                                <button
                                    className="menu-btn"
                                    style={{ 
                                        background: musicEnabled ? '#32CD32' : '#666',
                                        fontSize: '14px',
                                        padding: '8px 16px',
                                        marginBottom: '10px'
                                    }}
                                    onClick={toggleMusic}
                                >
                                    üéµ Èü≥Ê•Ω: {musicEnabled ? 'ON' : 'OFF'}
                                </button>
                                
                                {/* BGMÂ§âÊõ¥„Éú„Çø„É≥ */}
                                {musicEnabled && audioManagerRef.current && (
                                    <button
                                        className="menu-btn"
                                        style={{ 
                                            background: '#FF6347',
                                            fontSize: '12px',
                                            padding: '6px 12px',
                                            marginBottom: '10px',
                                            marginLeft: '10px'
                                        }}
                                        onClick={() => {
                                            if (audioManagerRef.current) {
                                                const newBGM = audioManagerRef.current.changeBGM();
                                                console.log('BGMÂ§âÊõ¥:', newBGM);
                                                if (gameStarted) {
                                                    audioManagerRef.current.playBGM();
                                                }
                                            }
                                        }}
                                    >
                                        üîÑ BGMÂ§âÊõ¥
                                    </button>
                                )}
                                
                                {musicEnabled && (
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', alignItems: 'center' }}>
                                        <div style={{ fontSize: '12px', color: '#ccc' }}>
                                            BGMÈü≥Èáè: {Math.round(bgmVolume * 100)}%
                                            <input
                                                type="range"
                                                min="0"
                                                max="1"
                                                step="0.1"
                                                value={bgmVolume}
                                                onChange={(e) => setBgmVolume(parseFloat(e.target.value))}
                                                style={{ marginLeft: '10px', width: '100px' }}
                                            />
                                        </div>
                                        <div style={{ fontSize: '12px', color: '#ccc' }}>
                                            ÂäπÊûúÈü≥Èü≥Èáè: {Math.round(sfxVolume * 100)}%
                                            <input
                                                type="range"
                                                min="0"
                                                max="1"
                                                step="0.1"
                                                value={sfxVolume}
                                                onChange={(e) => setSfxVolume(parseFloat(e.target.value))}
                                                style={{ marginLeft: '10px', width: '100px' }}
                                            />
                                        </div>
                                        <div style={{ fontSize: '10px', color: '#999', textAlign: 'center', maxWidth: '300px' }}>
                                            üéº BGMÊ•ΩÊõ≤: „Ç∑„É≥„Ç∞„É´„Éô„É´, „Å©„ÅçÔºÅ, „ÅØ„ÇÄ„Éñ„É´, „Å∂„Å°„ÅÇ„Åí, „Åæ„ÄÅ„Çã„ÄÅ„Å°„ÇÉ„ÄÅ„ÇìÔºÅ, Èõ®, Êàë„ÄÖ„ÅØHamCup, ARE YOU FUMA, Give & Love, HamCupÂõΩÊ≠å, Hey yo what's up men bro, Tommy's soliloquy 86', „Åä„Éº„Åï„Éº„ÇÜÔºÅ<br/>
                                            üîä ÂäπÊûúÈü≥: „Ç∑„É≥„Éó„É´„Å™ÈõªÂ≠êÈü≥
                                        </div>
                                    </div>
                                )}
                            </div>
                            <div className="character-grid-scroll" style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(5, 1fr)',
                                gap: '18px',
                                justifyItems: 'center',
                                maxWidth: 600
                            }}>
                                {Object.entries(CHARACTER_STATS).map(([id, char]) => (
                                    <div
                                        key={id}
                                        style={{
                                            border: selectedCharacter === id ? '4px solid #FFD700' : '2px solid #333',
                                            borderRadius: 12,
                                            background: selectedCharacter === id ? '#fffbe6' : '#222',
                                            padding: 8,
                                            cursor: 'pointer',
                                            boxShadow: selectedCharacter === id ? '0 0 12px #FFD700' : 'none',
                                            transition: 'all 0.2s',
                                            width: 90,
                                            textAlign: 'center'
                                        }}
                                        onClick={() => setSelectedCharacter(id)}
                                    >
                                        <img
                                            src={`images/${id}.png`}
                                            alt={char.name}
                                            style={{ width: 64, height: 64, borderRadius: 8, background: '#fff' }}
                                        />
                                        <div style={{ fontWeight: 'bold', marginTop: 4 }}>{char.emoji} {char.name}</div>
                                    </div>
                                ))}
                            </div>
                            <div className="character-select-bottom">
                                {selectedCharacter && (
                                    <div style={{
                                        background: '#222',
                                        borderRadius: 12,
                                        padding: 16,
                                        margin: '0 auto 20px',
                                        maxWidth: 340,
                                        color: '#fff',
                                        boxShadow: '0 2px 8px #0008'
                                    }}>
                                        <div style={{ fontSize: 22, fontWeight: 'bold', marginBottom: 6 }}>
                                            {CHARACTER_STATS[selectedCharacter].emoji} {CHARACTER_STATS[selectedCharacter].name}
                                        </div>
                                        <div style={{ fontSize: 15, marginBottom: 6 }}>
                                            <span style={{ color: '#FFD700' }}>ÁâπÊäÄÔºö</span>{CHARACTER_STATS[selectedCharacter].specialty}
                                        </div>
                                        <div style={{ display: 'flex', gap: 12, fontSize: 14, justifyContent: 'center' }}>
                                            <span>„Çπ„Éî„Éº„Éâ: {CHARACTER_STATS[selectedCharacter].speed}</span>
                                            <span>„Ç∏„É£„É≥„Éó: {CHARACTER_STATS[selectedCharacter].jump}</span>
                                            <span>„Çµ„Ç§„Ç∫: {CHARACTER_STATS[selectedCharacter].size}</span>
                                        </div>
                                    </div>
                                )}
                                <button
                                    className="menu-btn"
                                    style={{ marginTop: 10, background: selectedCharacter ? '#0066ff' : '#888', cursor: selectedCharacter ? 'pointer' : 'not-allowed' }}
                                    disabled={!selectedCharacter}
                                    onClick={() => {
                                        if (!selectedCharacter) return;
                                        setPlayerCharId(selectedCharacter);
                                        // AI„Ç≠„É£„É©„ÇíÊú™ÈÅ∏Êäû„Ç≠„É£„É©„Åã„Çâ„É©„É≥„ÉÄ„É†„ÅßÊ±∫ÂÆö
                                        const aiCandidates = Object.keys(CHARACTER_STATS).filter(id => id !== selectedCharacter);
                                        setAiCharId(aiCandidates[Math.floor(Math.random() * aiCandidates.length)]);
                                        setStep(1); // Èõ£ÊòìÂ∫¶ÈÅ∏Êäû„Å∏
                                    }}
                                >
                                    „Åì„ÅÆ„Ç≠„É£„É©„ÅßÊ±∫ÂÆöÔºÅ
                                </button>
                            </div>
                        </div>
                    )}
                    
                    {/* Èõ£ÊòìÂ∫¶ÈÅ∏ÊäûÁîªÈù¢ */}
                    {step === 1 && (
                        <div className="menu-container">
                            <h2>AI„ÅÆÈõ£ÊòìÂ∫¶„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</h2>
                            <div className="menu-buttons">
                                <button
                                    className="menu-btn"
                                    onClick={() => {
                                        window.aiDifficulty = { label: '„Åã„Çì„Åü„Çì', delay: 500 };
                                        setStep(2);
                                    }}
                                >
                                    „Åã„Çì„Åü„Çì<br /><span style={{ fontSize: 13, color: '#FFD700' }}>ÔºàÂèçÂøúÈÅÖ„ÇÅÔºâ</span>
                                </button>
                                <button
                                    className="menu-btn"
                                    onClick={() => {
                                        window.aiDifficulty = { label: '„Åµ„Å§„ÅÜ', delay: 200 };
                                        setStep(2);
                                    }}
                                >
                                    „Åµ„Å§„ÅÜ<br /><span style={{ fontSize: 13, color: '#00CED1' }}>ÔºàÊ®ôÊ∫ñÔºâ</span>
                                </button>
                                <button
                                    className="menu-btn"
                                    onClick={() => {
                                        window.aiDifficulty = { label: '„ÇÄ„Åö„Åã„Åó„ÅÑ', delay: 0 };
                                        setStep(2);
                                    }}
                                >
                                    „ÇÄ„Åö„Åã„Åó„ÅÑ<br /><span style={{ fontSize: 13, color: '#DC143C' }}>ÔºàÂç≥ÊôÇÂèçÂøúÔºâ</span>
                                </button>
                            </div>
                            <button
                                className="menu-btn"
                                style={{ marginTop: 20, background: '#666' }}
                                onClick={() => setStep(0)}
                            >
                                „Ç≠„É£„É©ÈÅ∏Êäû„Å´Êàª„Çã
                            </button>
                        </div>
                    )}
                    
                    {/* Ë©¶ÂêàÊôÇÈñìÈÅ∏ÊäûÁîªÈù¢ */}
                    {step === 2 && (
                        <div className="menu-container">
                            <h2>Ë©¶ÂêàÊôÇÈñì„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ</h2>
                            <div className="game-info">
                                <span style={{ color: CHARACTER_STATS[playerCharId]?.color, fontWeight: 'bold' }}>
                                    {CHARACTER_STATS[playerCharId]?.emoji} {CHARACTER_STATS[playerCharId]?.name}
                                </span>
                                <span> vs </span>
                                <span style={{ color: CHARACTER_STATS[aiCharId]?.color, fontWeight: 'bold' }}>
                                    {CHARACTER_STATS[aiCharId]?.emoji} {CHARACTER_STATS[aiCharId]?.name}
                                </span>
                            </div>
                            <div className="menu-buttons">
                                <button className="menu-btn" onClick={() => { setGameMode('1min'); setTimeLeft(60); setStep(3); setGameStarted(true); resetGame(); }}>1ÂàÜ</button>
                                <button className="menu-btn" onClick={() => { setGameMode('2min'); setTimeLeft(120); setStep(3); setGameStarted(true); resetGame(); }}>2ÂàÜ</button>
                                <button className="menu-btn" onClick={() => { setGameMode('4min'); setTimeLeft(240); setStep(3); setGameStarted(true); resetGame(); }}>4ÂàÜ</button>
                                <button className="menu-btn" onClick={() => { setGameMode('8min'); setTimeLeft(480); setStep(3); setGameStarted(true); resetGame(); }}>8ÂàÜ</button>
                                <button className="menu-btn" onClick={() => { setGameMode('worldcup'); setTimeLeft(300); setStep(3); setGameStarted(true); resetGame(); }}>„ÉØ„Éº„É´„Éâ„Ç´„ÉÉ„Éó</button>
                            </div>
                            <button
                                className="menu-btn"
                                style={{ marginTop: 20, background: '#666' }}
                                onClick={() => setStep(1)}
                            >
                                Èõ£ÊòìÂ∫¶ÈÅ∏Êäû„Å´Êàª„Çã
                            </button>
                        </div>
                    )}
                    
                    {(gameStarted || winner) && (
                        <>
                            <div className="score-display">
                                <span>Èùí„ÉÅ„Éº„É†: {score.left}</span>
                                <span>{formatTime(timeLeft)}</span>
                                <span>{score.right} : Ëµ§„ÉÅ„Éº„É†</span>
                            </div>
                            
                            <canvas
                                ref={canvasRef}
                                width={GAME_WIDTH}
                                height={GAME_HEIGHT}
                            />
                            
                            {/* „Éú„Çø„É≥„Å™„Åó„ÄÅ„Ç≥„É≥„Éà„É≠„Éº„É´„ÅØ„Çπ„ÉØ„Ç§„Éó/„Çø„ÉÉ„ÉóÂ∞ÇÁî® */}

                            {winner && (
                                <div className="menu-container" style={{ position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', background: 'rgba(0,0,0,0.9)', padding: '30px', borderRadius: '10px' }}>
                                    <h2 style={{ fontSize: '2rem', marginBottom: '20px' }}>
                                        {winner === 'Âºï„ÅçÂàÜ„Åë' ? 'Âºï„ÅçÂàÜ„ÅëÔºÅ' : `${winner}„ÅÆÂãùÂà©ÔºÅ`}
                                    </h2>
                                    <button
                                        onClick={() => {
                                            setStep(0);
                                            setGameStarted(false);
                                            setGameMode(null);
                                            setPlayerCharId(null);
                                            setAiCharId(null);
                                            setWinner(null);
                                            setScore({ left: 0, right: 0 });
                                            setTimeLeft(0);
                                        }}
                                        className="menu-btn"
                                    >
                                        „É°„Éã„É•„Éº„Å´Êàª„Çã
                                    </button>
                                </div>
                            )}
                        </>
                    )}
                </div>
            );
        };
        
        ReactDOM.render(<SlimeSoccerMobile />, document.getElementById('root'));
    </script>
</body>
</html>
