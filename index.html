<!doctype html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- å…¨ç”»é¢è¡¨ç¤ºã®ãŸã‚ã®è¿½åŠ metaã‚¿ã‚° -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>ã˜ã‚ƒãŒã‚Šã‚“ã‚¹ãƒ©ã‚¤ãƒ ã‚µãƒƒã‚«ãƒ¼</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            touch-action: auto; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ™‚ã¯è¨±å¯ */
            overflow-y: auto; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ™‚ã¯è¨±å¯ */
            /* ãƒãƒƒãƒ/ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰å¯¾å¿œã®ãŸã‚ã®safe-areaèª¿æ•´ */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        
        #root {
            width: 100vw;
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        
        .game-container {
            width: 100vw;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }
        
        .character-grid-scroll {
            max-height: 60vh;
            overflow-y: auto;
            margin: 30px auto 0 auto;
            width: 100%;
        }

        .character-select-bottom {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: sticky;
            bottom: 0;
            background: #1a1a2e;
            padding-bottom: 24px;
            z-index: 10;
        }

        canvas {
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw;
            max-height: 100vh;
            border: 2px solid #333;
            background: #0066ff;
            touch-action: none;
            display: block;
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #fff;
            background: rgba(0, 102, 255, 0.8);
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        .control-btn:active {
            background: rgba(0, 102, 255, 1);
            transform: scale(0.95);
        }
        
        .direction-controls {
            display: flex;
            gap: 10px;
        }
        
        .menu-btn {
            padding: 12px 24px;
            margin: 10px;
            background: #0066ff;
            color: white;
            border: 2px solid #333;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .menu-btn:active {
            background: #0052cc;
            transform: scale(0.95);
        }
        
        .score-display {
            background: #0066ff;
            padding: 15px 30px;
            border-radius: 8px 8px 0 0;
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            padding-top: calc(15px + env(safe-area-inset-top));
        }
        
        .game-info {
            text-align: center;
            margin: 20px;
        }
        
        .menu-container {
            text-align: center;
            padding: 20px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #fff;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        @media (orientation: landscape) {
            canvas {
                max-height: 100vh;
            }
            
            .controls {
                bottom: 10px;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }
            
            .score-display {
                font-size: 16px;
                padding: 10px 20px;
            }
            
            .control-btn {
                width: 55px;
                height: 55px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/javascript">
        const formatTime = (seconds) => {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        };
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 400;
        const GROUND_HEIGHT = 80;
        const SLIME_RADIUS = 40;
        const BALL_RADIUS = 10;
        const GOAL_WIDTH = 80;
        const GOAL_HEIGHT = 120;
        const GRAVITY = 0.6;
        const SLIME_SPEED = 5;
        const SLIME_JUMP_POWER = -12;
        const BALL_DAMPING = 0.99;
        const BALL_BOUNCE_DAMPING = 0.8;
        const MAX_BALL_SPEED = 13;
        
            // åŠ¹æœéŸ³ç”¨ã®ã‚·ãƒ³ãƒ—ãƒ«ãªé–¢æ•°ï¼ˆã‚¨ãƒ©ãƒ¼å›é¿ï¼‰
            const playSimpleBeep = (frequency, duration, volume = 0.3) => {
                try {
                    // AudioContextã®ä½œæˆã¨ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) {
                        console.log('Web Audio API not supported');
                        return;
                    }
                    
                    const audioContext = new AudioContext();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                    
                    // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
                    setTimeout(() => {
                        try {
                            audioContext.close();
                        } catch (e) {
                            // ã‚¯ãƒ­ãƒ¼ã‚ºã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                        }
                    }, (duration + 0.1) * 1000);
                    
                } catch (error) {
                    console.log('åŠ¹æœéŸ³å†ç”Ÿã‚¨ãƒ©ãƒ¼:', error);
                }
            };
        // BGMç”¨Audioè¦ç´ ã®ç®¡ç†
        const createAudioManager = () => {
            const bgmAudio = new Audio();
            
            // BGMãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ï¼ˆå…¨ã¦ã‚ãªãŸã®æ¥½æ›²ï¼‰
            const bgmFiles = [
                'musics/ã‚·ãƒ³ã‚°ãƒ«ãƒ™ãƒ« (Remastered).mp3',
                'musics/ã©ãï¼.mp3',
                'musics/ã¯ã‚€ãƒ–ãƒ«.mp3',
                'musics/ã¶ã¡ã‚ã’.mp3',
                'musics/ã¾ã€ã‚‹ã€ã¡ã‚ƒã€ã‚“ï¼.mp3',
                'musics/é›¨.mp3',
                'musics/æˆ‘ã€…ã¯HamCup.mp3',
                'musics/ARE YOU FUMA.mp3',
                'musics/Give &  Love.mp3',
                'musics/HamCupå›½æ­Œ.mp3',
                'musics/Hey, yo, what\'s up men_ bro..mp3',
                'musics/Tommy\'s soliloquy 86\'.mp3',
                'musics/ãŠãƒ¼ã•ãƒ¼ã‚†ï¼.mp3'
            ];
            
            // ãƒ©ãƒ³ãƒ€ãƒ ã«BGMã‚’é¸æŠ
            let randomBGM = bgmFiles[Math.floor(Math.random() * bgmFiles.length)];
            bgmAudio.src = randomBGM;
            bgmAudio.loop = true;
            bgmAudio.volume = 0.6;
            
            // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¿½åŠ 
            bgmAudio.addEventListener('error', function(e) {
                console.log('BGMèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
            });
            
            return {
                bgm: bgmAudio,
                currentBGM: randomBGM,
                bgmFiles: bgmFiles,
                playBGM: function() {
                    return new Promise(function(resolve, reject) {
                        try {
                            bgmAudio.currentTime = 0;
                            const playPromise = bgmAudio.play();
                            if (playPromise && typeof playPromise.then === 'function') {
                                playPromise.then(function() {
                                    console.log('BGMé–‹å§‹:', randomBGM);
                                    resolve();
                                }).catch(function(error) {
                                    console.log('BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼:', error);
                                    reject(error);
                                });
                            } else {
                                console.log('BGMé–‹å§‹:', randomBGM);
                                resolve();
                            }
                        } catch (error) {
                            console.log('BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼:', error);
                            reject(error);
                        }
                    });
                },
                stopBGM: function() {
                    try {
                        bgmAudio.pause();
                        bgmAudio.currentTime = 0;
                    } catch (error) {
                        console.log('BGMåœæ­¢ã‚¨ãƒ©ãƒ¼:', error);
                    }
                },
                playKick: function() {
                    const volume = window.sfxVolume || 0.3;
                    if (volume > 0) {
                        playSimpleBeep(200, 0.1, volume * 0.3);
                    }
                },
                playGoal: function() {
                    const volume = window.sfxVolume || 0.3;
                    if (volume > 0) {
                        playSimpleBeep(400, 0.2, volume * 0.4);
                        setTimeout(function() { playSimpleBeep(500, 0.2, volume * 0.4); }, 100);
                        setTimeout(function() { playSimpleBeep(600, 0.3, volume * 0.4); }, 200);
                    }
                },
                setBGMVolume: function(volume) {
                    try {
                        bgmAudio.volume = Math.max(0, Math.min(1, volume));
                    } catch (error) {
                        console.log('éŸ³é‡è¨­å®šã‚¨ãƒ©ãƒ¼:', error);
                    }
                },
                setSFXVolume: function(volume) {
                    window.sfxVolume = Math.max(0, Math.min(1, volume));
                },
                changeBGM: function() {
                    try {
                        const newBGM = bgmFiles[Math.floor(Math.random() * bgmFiles.length)];
                        bgmAudio.src = newBGM;
                        randomBGM = newBGM;
                        return newBGM;
                    } catch (error) {
                        console.log('BGMå¤‰æ›´ã‚¨ãƒ©ãƒ¼:', error);
                        return randomBGM;
                    }
                },
                getCurrentBGMName: function() {
                    try {
                        const fileName = bgmAudio.src.split('/').pop();
                        return fileName ? decodeURIComponent(fileName.replace('.mp3', '')) : 'Unknown';
                    } catch (error) {
                        return 'Unknown';
                    }
                }
            };
        };
        /**
         * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ï¼ˆç”»åƒãƒ•ã‚¡ã‚¤ãƒ«åã¯ images/001.png ï½ images/029.pngï¼‰
         */
        const CHARACTER_STATS = {
          '001': { name: "ã˜ã‚ƒãŒ", speed: 1.2, jump: 1.1, size: 1.0, color: "#D4AF37", specialty: "ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—", emoji: "ğŸ‘‘" },
          '002': { name: "ã•ãã‚‰", speed: 1.0, jump: 1.0, size: 0.9, color: "#FFB6C1", specialty: "å‹•ç‰©ã¨ä¼šè©±", emoji: "ğŸŒ¸" },
          '003': { name: "ãƒ—ãƒªãƒ³", speed: 0.8, jump: 0.9, size: 1.1, color: "#F5DEB3", specialty: "æ³•å¾‹ç›¸è«‡", emoji: "ğŸ“š" },
          '004': { name: "ã‹ã·ã¡ãƒ¼ã‚‚", speed: 1.1, jump: 1.0, size: 1.0, color: "#DEB887", specialty: "æ–™ç†", emoji: "ğŸ‘¨â€ğŸ³" },
          '005': { name: "ãƒãƒ å¨˜", speed: 0.9, jump: 1.0, size: 0.9, color: "#FF69B4", specialty: "åŒ»ç™‚", emoji: "ğŸ’Š" },
          '006': { name: "ãã¹ã—", speed: 1.3, jump: 1.2, size: 1.0, color: "#32CD32", specialty: "å†’é™º", emoji: "ğŸ—¡ï¸" },
          '007': { name: "ãƒªãƒ§ãƒ¼ã‚¿", speed: 1.2, jump: 1.3, size: 1.1, color: "#87CEEB", specialty: "ã‚¹ãƒãƒ¼ãƒ„", emoji: "âš½" },
          '008': { name: "ãƒãƒ ã¾ã‚", speed: 0.8, jump: 0.9, size: 1.0, color: "#F0F8FF", specialty: "æˆ¦ç•¥", emoji: "ğŸ§ " },
          '009': { name: "ãƒªãƒ¼ã‚¼ãƒ³ãƒˆä¸¸", speed: 1.0, jump: 1.0, size: 1.0, color: "#90EE90", specialty: "é›†è¨ˆ", emoji: "ğŸ“Š" },
          '010': { name: "ã‚‚ã¿ã˜", speed: 1.0, jump: 1.1, size: 0.9, color: "#FF6347", specialty: "ã‚«ã‚¦ãƒ³ã‚»ãƒªãƒ³ã‚°", emoji: "ğŸ" },
          '011': { name: "ã‚¢ã‚¯ã‚¢", speed: 1.1, jump: 1.2, size: 1.0, color: "#00CED1", specialty: "ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢", emoji: "âš™ï¸" },
          '012': { name: "ã†ãšã‚‰", speed: 0.9, jump: 1.0, size: 1.0, color: "#DDA0DD", specialty: "ãƒ—ãƒ­ãƒãƒ", emoji: "ğŸ“‹" },
          '013': { name: "ã™ã„ã‚ã„", speed: 1.1, jump: 1.4, size: 0.9, color: "#B0E0E6", specialty: "å¿è¡“", emoji: "ğŸ¥·" },
          '014': { name: "ãƒãƒ ã‚Šã‚“", speed: 1.3, jump: 1.0, size: 0.8, color: "#FFD700", specialty: "ã‚®ãƒ£ãƒ³ãƒ–ãƒ«", emoji: "ğŸ²" },
          '015': { name: "ãƒ©ãƒƒã‚­ãƒ¼", speed: 1.0, jump: 1.1, size: 1.0, color: "#DA70D6", specialty: "é‡‘åº«ç•ª", emoji: "ğŸ’°" },
          '016': { name: "ãªãªã„ã‚", speed: 1.2, jump: 1.3, size: 0.8, color: "#9370DB", specialty: "ç™ºæ˜", emoji: "ğŸ”¬" },
          '017': { name: "ãã‚ŠåŠ", speed: 0.9, jump: 1.1, size: 1.2, color: "#8B4513", specialty: "æ ¼é—˜æŠ€", emoji: "ğŸ‘Š" },
          '018': { name: "ã¿ãŸã‚‰ã—", speed: 1.1, jump: 1.0, size: 1.0, color: "#CD853F", specialty: "ä½•ã§ã‚‚å±‹", emoji: "ğŸ› ï¸" },
          '019': { name: "ã‚¿ãƒ³ã‚´", speed: 1.0, jump: 1.2, size: 1.0, color: "#2F4F4F", specialty: "ãƒ„ãƒƒã‚³ãƒŸ", emoji: "ğŸ˜¤" },
          '020': { name: "ã¤ã„ã¦ã‚‹", speed: 1.1, jump: 1.1, size: 0.9, color: "#F0E68C", specialty: "ã‚¨ãƒ³ã‚¿ãƒ¡", emoji: "ğŸ­" },
          '021': { name: "ãƒã‚¯", speed: 1.2, jump: 1.4, size: 0.9, color: "#4169E1", specialty: "ã‚µã‚¤ã‚­ãƒƒã‚¯", emoji: "ğŸ”®" },
          '022': { name: "ã“ã®ã¯", speed: 1.1, jump: 1.0, size: 1.0, color: "#228B22", specialty: "äººç”Ÿç›¸è«‡", emoji: "ğŸŒ»" },
          '023': { name: "ãŸã„ã‚ã‚“", speed: 1.4, jump: 1.1, size: 1.1, color: "#FF4500", specialty: "é‹è»¢", emoji: "ğŸï¸" },
          '024': { name: "ãƒãƒ ãƒ¬ãƒƒãƒˆ", speed: 1.2, jump: 1.2, size: 1.0, color: "#483D8B", specialty: "ãƒ’ãƒ¼ãƒ­ãƒ¼", emoji: "ğŸ¦¸" },
          '025': { name: "ã‚¯ãƒªã‚ªãƒã‚¢", speed: 1.3, jump: 1.0, size: 0.8, color: "#87CEFA", specialty: "å®´ä¼šéƒ¨é•·", emoji: "ğŸ‰" },
          '026': { name: "ã‚€ã‚‰ã‚€ã™ã‚", speed: 1.2, jump: 1.1, size: 1.0, color: "#FF1493", specialty: "ã‚®ãƒ£ãƒ«", emoji: "ğŸ’…" },
          '027': { name: "ã‚ã‚“ã¿ã¤å§«", speed: 0.9, jump: 1.0, size: 1.0, color: "#DDA0DD", specialty: "ãŠå¬¢æ§˜", emoji: "ğŸ‘¸" },
          '028': { name: "ã¹ã«ãŸã‚“", speed: 1.0, jump: 1.1, size: 1.0, color: "#DC143C", specialty: "èŠ¸è¡“å®¶", emoji: "ğŸ¨" },
          '029': { name: "ã‚‚ãªã¡ã‚ƒã‚“", speed: 1.0, jump: 1.2, size: 0.9, color: "#708090", specialty: "æ˜Ÿå ã„", emoji: "â­" }
        };
        
        const SlimeSoccerMobile = () => {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);
            const lastFrameTimeRef = useRef(0);
            const backgroundImageRef = useRef(null);
            
            // Game state
            const [gameMode, setGameMode] = useState(null);
            const [timeLeft, setTimeLeft] = useState(0);
            const [score, setScore] = useState({ left: 0, right: 0 });
            const [gameStarted, setGameStarted] = useState(false);
            const [winner, setWinner] = useState(null);
            
            // èƒŒæ™¯ç”»åƒã®çŠ¶æ…‹ã‚’è¿½åŠ 
            const [backgroundImage, setBackgroundImage] = useState(null);
            const backgroundImages = [
                'images/h1.png', 'images/h2.png', 'images/h3.png', 'images/h4.png', 
                'images/h5.jpg', 'images/h6.png', 'images/h7.png', 'images/h8.png',
                'images/h9.png', 'images/h10.png', 'images/h11.png', 'images/h12.png', 'images/h13.png'
            ];
            
            // BGMã¨åŠ¹æœéŸ³ã®ç®¡ç†
            const audioManagerRef = useRef(null);
            const [musicEnabled, setMusicEnabled] = useState(true);
            const [bgmVolume, setBgmVolume] = useState(0.6);
            const [sfxVolume, setSfxVolume] = useState(0.8);
            
            // éŸ³æ¥½ã®åˆæœŸåŒ–
            useEffect(() => {
                if (!audioManagerRef.current) {
                    audioManagerRef.current = createAudioManager();
                }
            }, []);
            
            // Game objects state
            const gameStateRef = useRef({
                leftSlime: {
                    x: 200,
                    y: GAME_HEIGHT - GROUND_HEIGHT,
                    vx: 0,
                    vy: 0,
                    goalLineTime: 0,
                    targetX: 200,
                    lastDecisionTime: 0,
                    decisionCooldown: 0,
                    stableStart: true
                },
                rightSlime: {
                    x: 600,
                    y: GAME_HEIGHT - GROUND_HEIGHT,
                    vx: 0,
                    vy: 0,
                    goalLineTime: 0
                },
                ball: {
                    x: GAME_WIDTH / 2,
                    y: 150,
                    vx: 0,
                    vy: 0,
                    grabbedBy: null,
                    grabAngle: 0,
                    grabAngularVelocity: 0
                }
            });
            
            // SlimeSoccerMobileã®stateã«playerCharId, aiCharId, stepï¼ˆç”»é¢é·ç§»ç”¨ï¼‰ã‚’è¿½åŠ 
            const [playerCharId, setPlayerCharId] = useState(null);
            const [aiCharId, setAiCharId] = useState(null);
            const [step, setStep] = useState(0); // 0: ãƒ¡ãƒ‹ãƒ¥ãƒ¼, 1: é›£æ˜“åº¦é¸æŠ, 2: è©¦åˆæ™‚é–“é¸æŠ, 3: ã‚²ãƒ¼ãƒ 
            
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é¸æŠç”»é¢ã®UIã‚’è¿½åŠ 
            const [selectedCharacter, setSelectedCharacter] = useState(null);

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼/ã‚²ãƒ¼ãƒ æ™‚ã®bodyã‚¹ã‚¿ã‚¤ãƒ«åˆ‡ã‚Šæ›¿ãˆ
            useEffect(() => {
                if (step === 3 || gameStarted) {
                    document.body.style.touchAction = 'none';
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.touchAction = 'auto';
                    document.body.style.overflow = 'auto';
                }
            }, [step, gameStarted]);

            // Timer
            useEffect(() => {
                if (gameStarted && timeLeft > 0) {
                    const timer = setInterval(() => {
                        setTimeLeft(prev => {
                            if (prev <= 1) {
                                setGameStarted(false);
                                determineWinner();
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                    
                    return () => clearInterval(timer);
                }
            }, [gameStarted, timeLeft]);
            
            const determineWinner = () => {
                if (score.left > score.right) {
                    setWinner('é’ãƒãƒ¼ãƒ ');
                } else if (score.right > score.left) {
                    setWinner('èµ¤ãƒãƒ¼ãƒ ');
                } else {
                    setWinner('å¼•ãåˆ†ã‘');
                }
            };
            
            // ã‚¹ãƒ©ã‚¤ãƒ åˆæœŸåŒ–ãƒ»ãƒªã‚»ãƒƒãƒˆæ™‚ã®yåº§æ¨™ã‚’ä¸­å¿ƒåŸºæº–ã«ä¿®æ­£
            const resetPositions = () => {
                const state = gameStateRef.current;
                const leftRadius = getSlimeRadius(aiCharId);
                const rightRadius = getSlimeRadius(playerCharId);
                state.leftSlime.x = 200;
                state.leftSlime.y = (GAME_HEIGHT - GROUND_HEIGHT) - leftRadius; // ä¸­å¿ƒy
                state.leftSlime.vx = 0;
                state.leftSlime.vy = 0;
                state.leftSlime.goalLineTime = 0;
                state.leftSlime.targetX = 200;
                state.leftSlime.lastDecisionTime = 0;
                state.leftSlime.decisionCooldown = 0;
                state.leftSlime.stableStart = true;

                state.rightSlime.x = 600;
                state.rightSlime.y = (GAME_HEIGHT - GROUND_HEIGHT) - rightRadius; // ä¸­å¿ƒy
                state.rightSlime.vx = 0;
                state.rightSlime.vy = 0;
                state.rightSlime.goalLineTime = 0;

                state.ball.x = GAME_WIDTH / 2;
                state.ball.y = 150;
                state.ball.vx = 0;
                state.ball.vy = 0;
                state.ball.grabbedBy = null;
                state.ball.grabAngle = 0;
                state.ball.grabAngularVelocity = 0;
            };
            
            const resetGame = () => {
                resetPositions();
                setScore({ left: 0, right: 0 });
                setWinner(null);
                // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«èƒŒæ™¯ã‚’ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
                const randomIndex = Math.floor(Math.random() * backgroundImages.length);
                setBackgroundImage(backgroundImages[randomIndex]);
                
                // BGMé–‹å§‹
                if (musicEnabled && audioManagerRef.current) {
                    audioManagerRef.current.playBGM();
                }
            };
            
            // ã‚²ãƒ¼ãƒ æœ¬ä½“ã®ã‚­ãƒ£ãƒ©èƒ½åŠ›ãƒ»AIé›£æ˜“åº¦åæ˜ ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
            const getCharStats = (id) => CHARACTER_STATS[id] || { speed: 1, jump: 1, size: 1, color: '#888', name: '', emoji: '' };
            
            // AIè¡Œå‹•ã‚¿ã‚¤ãƒãƒ¼
            const aiLastUpdateRef = useRef(0);

            // updateAI: AIã‚­ãƒ£ãƒ©ã®èƒ½åŠ›å€¤ãƒ»é›£æ˜“åº¦åæ˜ 
            const updateAI = useCallback((currentTime) => {
                if (!aiCharId) return;
                const state = gameStateRef.current;
                const ai = state.leftSlime;
                const ball = state.ball;
                const stats = getCharStats(aiCharId);
                const aiDelay = window.aiDifficulty?.delay ?? 200;
                if (currentTime - aiLastUpdateRef.current < aiDelay) return;
                aiLastUpdateRef.current = currentTime;
                // AI: ãƒœãƒ¼ãƒ«ã‚’è¿½ã„ã‹ã‘ã‚‹
                if (ball.x < ai.x - 20) {
                    ai.vx = -SLIME_SPEED * stats.speed;
                } else if (ball.x > ai.x + 20) {
                    ai.vx = SLIME_SPEED * stats.speed;
                } else {
                    ai.vx = 0;
                }
                // ã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆæ¡ä»¶ã‚’-100ã«èª¿æ•´ã—ã¦éå‰°ã‚¸ãƒ£ãƒ³ãƒ—é˜²æ­¢ï¼‰
                if (ball.y < ai.y - 100 && Math.abs(ball.x - ai.x) < 100 && ai.vy === 0) {
                    ai.vy = SLIME_JUMP_POWER * stats.jump;
                }
            }, [aiCharId]);

            // ã‚¹ãƒ©ã‚¤ãƒ ã®åœ°é¢ä½ç½®è¨ˆç®—ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
            const getSlimeRadius = (charId) => SLIME_RADIUS * Math.max(0.85, getCharStats(charId).size) * 1.4;
            // åœ°é¢ã®Yåº§æ¨™
            const groundY = GAME_HEIGHT - GROUND_HEIGHT;

            // --- ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ç”¨ã‚¿ãƒƒãƒãƒ»ãƒœã‚¿ãƒ³æ“ä½œãƒãƒ³ãƒ‰ãƒ© ---
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œçŠ¶æ…‹
            const playerControlRef = useRef({ vx: 0, jump: false });
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯çŠ¶æ…‹
            const joystickRef = useRef({ active: false, centerX: 0, centerY: 0, currentX: 0, currentY: 0, radius: 50 });
            // ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
            useEffect(() => {
                const down = (e) => {
                    if (e.repeat) return;
                    if (e.key === 'ArrowLeft') playerControlRef.current.vx = -SLIME_SPEED;
                    if (e.key === 'ArrowRight') playerControlRef.current.vx = SLIME_SPEED;
                    if (e.key === ' ' || e.key === 'ArrowUp') playerControlRef.current.jump = true;
                };
                const up = (e) => {
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') playerControlRef.current.vx = 0;
                    if (e.key === ' ' || e.key === 'ArrowUp') playerControlRef.current.jump = false;
                };
                window.addEventListener('keydown', down);
                window.addEventListener('keyup', up);
                return () => {
                    window.removeEventListener('keydown', down);
                    window.removeEventListener('keyup', up);
                };
            }, []);

            // --- ä»®æƒ³ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã¨ã‚¿ãƒƒãƒã‚¸ãƒ£ãƒ³ãƒ—ã‚¤ãƒ™ãƒ³ãƒˆ ---
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                let joystickTouchId = -1; // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å°‚ç”¨ã‚¿ãƒƒãƒID
                let jumpActive = false;
                const scaleX = GAME_WIDTH / canvas.clientWidth;
                const scaleY = GAME_HEIGHT / canvas.clientHeight;
                const handleTouchStart = (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        const x = touch.clientX * scaleX;
                        const y = touch.clientY * scaleY;
                        if (joystickTouchId === -1 && x < GAME_WIDTH / 2 && y > GAME_HEIGHT / 2) {
                            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯æ´»æ€§åŒ–
                            joystickTouchId = touch.identifier;
                            joystickRef.current.active = true;
                            joystickRef.current.centerX = x;
                            joystickRef.current.centerY = y;
                            joystickRef.current.currentX = x;
                            joystickRef.current.currentY = y;
                        } else {
                            // å³å´é™å®šã§ã‚¸ãƒ£ãƒ³ãƒ—
                            if (x > GAME_WIDTH / 2) {
                                jumpActive = true;
                                playerControlRef.current.jump = true;
                            }
                        }
                    }
                };
                const handleTouchMove = (e) => {
                    e.preventDefault();
                    for (let touch of e.touches) {
                        if (touch.identifier === joystickTouchId) {
                            const x = touch.clientX * scaleX;
                            const y = touch.clientY * scaleY;
                            const dx = x - joystickRef.current.centerX;
                            const dy = y - joystickRef.current.centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const maxDist = joystickRef.current.radius;
                            if (dist > maxDist) {
                                const angle = Math.atan2(dy, dx);
                                joystickRef.current.currentX = joystickRef.current.centerX + Math.cos(angle) * maxDist;
                                joystickRef.current.currentY = joystickRef.current.centerY + Math.sin(angle) * maxDist;
                            } else {
                                joystickRef.current.currentX = x;
                                joystickRef.current.currentY = y;
                            }
                            // vxæ›´æ–° (æ°´å¹³ç§»å‹•ã®ã¿)
                            playerControlRef.current.vx = (dx / maxDist) * SLIME_SPEED * getCharStats(playerCharId).speed;
                        }
                    }
                };
                const handleTouchEnd = (e) => {
                    e.preventDefault();
                    for (let touch of e.changedTouches) {
                        if (touch.identifier === joystickTouchId) {
                            joystickTouchId = -1;
                            joystickRef.current.active = false;
                            playerControlRef.current.vx = 0;
                        } else {
                            jumpActive = false;
                            playerControlRef.current.jump = false;
                        }
                    }
                };
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                return () => {
                    canvas.removeEventListener('touchstart', handleTouchStart);
                    canvas.removeEventListener('touchmove', handleTouchMove);
                    canvas.removeEventListener('touchend', handleTouchEnd);
                };
            }, [gameStarted, playerCharId]);

            // updatePhysics: ãƒœãƒ¼ãƒ«ãŒå¿…ãšä¸Šæ–¹å‘ã«å¼¾ã‹ã‚Œã‚‹ã‚ˆã†ã«ä¿®æ­£
            const updatePhysics = useCallback((currentTime) => {
                const state = gameStateRef.current;
                const playerStats = getCharStats(playerCharId);
                state.rightSlime.vx = playerControlRef.current.vx;
                // ã‚¸ãƒ£ãƒ³ãƒ—åˆ¤å®š
                const rightSlimeRadius = getSlimeRadius(playerCharId);
                if (playerControlRef.current.jump && state.rightSlime.y + rightSlimeRadius >= groundY - 1) {
                    state.rightSlime.vy = SLIME_JUMP_POWER * playerStats.jump;
                    playerControlRef.current.jump = false;
                }
                updateAI(currentTime);
                [state.leftSlime, state.rightSlime].forEach((slime, idx) => {
                    const charId = idx === 0 ? aiCharId : playerCharId;
                    const slimeRadius = getSlimeRadius(charId);
                    slime.vy += GRAVITY;
                    slime.x += slime.vx;
                    slime.y += slime.vy;
                    if (slime.x < slimeRadius) slime.x = slimeRadius;
                    if (slime.x > GAME_WIDTH - slimeRadius) slime.x = GAME_WIDTH - slimeRadius;
                    // åœ°é¢åˆ¤å®šï¼ˆåŠå††ä¸­å¿ƒåŸºæº–ï¼‰
                    if (slime.y + slimeRadius > groundY) {
                        slime.y = groundY - slimeRadius;
                        slime.vy = 0;
                    }
                });
                // ãƒœãƒ¼ãƒ«ç‰©ç†
                if (state.ball.grabbedBy) {
                    // ã‚°ãƒ©ãƒ–æ©Ÿèƒ½ã¯å‰Šé™¤æ¸ˆã¿
                } else {
                    state.ball.vy += GRAVITY;
                    state.ball.vx *= BALL_DAMPING;
                    state.ball.x += state.ball.vx;
                    state.ball.y += state.ball.vy;
                }
                // ãƒœãƒ¼ãƒ«ã®å£ãƒ»å¤©äº•ãƒ»åœ°é¢åç™º
                if (state.ball.x < BALL_RADIUS) {
                    state.ball.x = BALL_RADIUS;
                    state.ball.vx = -state.ball.vx * BALL_BOUNCE_DAMPING;
                }
                if (state.ball.x > GAME_WIDTH - BALL_RADIUS) {
                    state.ball.x = GAME_WIDTH - BALL_RADIUS;
                    state.ball.vx = -state.ball.vx * BALL_BOUNCE_DAMPING;
                }
                if (state.ball.y > groundY - BALL_RADIUS) {
                    state.ball.y = groundY - BALL_RADIUS;
                    state.ball.vy = -state.ball.vy * BALL_BOUNCE_DAMPING;
                }
                if (state.ball.y < BALL_RADIUS) {
                    state.ball.y = BALL_RADIUS;
                    state.ball.vy = -state.ball.vy * BALL_BOUNCE_DAMPING;
                }
                // ãƒœãƒ¼ãƒ«ã¨ã‚¹ãƒ©ã‚¤ãƒ ã®å½“ãŸã‚Šåˆ¤å®š - ã‚µãƒƒã‚«ãƒ¼ã®ã‚¯ãƒªã‚¢æ©Ÿèƒ½ä»˜ã
                [state.leftSlime, state.rightSlime].forEach((slime, idx) => {
                    const charId = idx === 0 ? aiCharId : playerCharId;
                    const slimeRadius = getSlimeRadius(charId);
                    // ã‚¹ãƒ©ã‚¤ãƒ ã®ä¸­å¿ƒåº§æ¨™ = (slime.x, slime.y)
                    const slimeCx = slime.x;
                    const slimeCy = slime.y;
                    const dx = state.ball.x - slimeCx;
                    const dy = state.ball.y - slimeCy;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < slimeRadius + BALL_RADIUS) {
                        // ãƒœãƒ¼ãƒ«ã¨ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æ¥è§¦æ™‚ã«åŠ¹æœéŸ³ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªé›»å­éŸ³ï¼‰
                        if (musicEnabled && audioManagerRef.current && window.sfxVolume > 0) {
                            audioManagerRef.current.playKick();
                        }
                        // è‡ªç„¶ãªåç™ºè§’åº¦ã‚’è¨ˆç®—
                        let angle = Math.atan2(dy, dx);
                        
                        // ãƒœãƒ¼ãƒ«ãŒåœ°é¢è¿‘ãã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚¯ãƒªã‚¢åˆ¤å®šï¼‰
                        const ballDistanceFromGround = groundY - BALL_RADIUS - state.ball.y;
                        const isBallNearGround = ballDistanceFromGround <= 30; // åœ°é¢ã‹ã‚‰30ãƒ”ã‚¯ã‚»ãƒ«ä»¥å†…
                        
                        if (isBallNearGround) {
                            // ã‚µãƒƒã‚«ãƒ¼ã®ã‚¯ãƒªã‚¢ã®ã‚ˆã†ãªå‹•ä½œ
                            console.log('Ground ball clear!'); // ãƒ‡ãƒãƒƒã‚°ç”¨
                            
                            // æ¨ªæ–¹å‘ã®æˆåˆ†ã¯ä¿æŒã—ã¤ã¤ã€ä¸Šæ–¹å‘ã‚’å¼·åŒ–
                            const horizontalDirection = dx > 0 ? 1 : -1;
                            
                            // ã‚¯ãƒªã‚¢æ™‚ã®è§’åº¦ï¼ˆ30åº¦ã€œ60åº¦ã®ç¯„å›²ã§ä¸Šå‘ãï¼‰
                            const clearAngleMin = -Math.PI / 3; // -60åº¦
                            const clearAngleMax = -Math.PI / 6; // -30åº¦
                            
                            if (horizontalDirection > 0) {
                                // å³æ–¹å‘ã®ã‚¯ãƒªã‚¢
                                angle = clearAngleMin + (clearAngleMax - clearAngleMin) * 0.7; // ã‚„ã‚„å³ä¸Š
                            } else {
                                // å·¦æ–¹å‘ã®ã‚¯ãƒªã‚¢
                                angle = Math.PI + clearAngleMin + (clearAngleMax - clearAngleMin) * 0.3; // ã‚„ã‚„å·¦ä¸Š
                            }
                        } else {
                            // é€šå¸¸ã®ç©ºä¸­ã§ã®ãƒœãƒ¼ãƒ«ï¼šã‚¹ãƒ©ã‚¤ãƒ ã®ä¸‹åŠåˆ†ã«å½“ãŸã£ãŸå ´åˆã®ã¿è»½ã„è£œæ­£
                            const slimeGroundY = slime.y + slimeRadius;
                            const ballRelativeY = state.ball.y - slimeGroundY;
                            
                            if (ballRelativeY > -slimeRadius * 0.3) {
                                // ãƒœãƒ¼ãƒ«ãŒã‚¹ãƒ©ã‚¤ãƒ ã®ä¸‹éƒ¨30%ã«å½“ãŸã£ãŸå ´åˆã€è»½ãä¸Šå‘ãã«è£œæ­£
                                if (angle > Math.PI * 0.4) {
                                    angle = Math.PI * 0.4; // 72åº¦ï¼ˆã‚„ã‚„ä¸Šå‘ãï¼‰
                                } else if (angle < -Math.PI * 0.4) {
                                    angle = -Math.PI * 0.4; // -72åº¦ï¼ˆã‚„ã‚„ä¸Šå‘ãï¼‰
                                }
                            }
                        }
                        
                        // ãƒœãƒ¼ãƒ«ã®æ–°ã—ã„ä½ç½®ã‚’è¨­å®š
                        const targetX = slimeCx + Math.cos(angle) * (slimeRadius + BALL_RADIUS);
                        const targetY = slimeCy + Math.sin(angle) * (slimeRadius + BALL_RADIUS);
                        state.ball.x = targetX;
                        state.ball.y = targetY;
                        
                        // é€Ÿåº¦è¨ˆç®—
                        const currentSpeed = Math.sqrt(state.ball.vx * state.ball.vx + state.ball.vy * state.ball.vy);
                        let baseSpeed;
                        
                        if (isBallNearGround) {
                            // ã‚¯ãƒªã‚¢æ™‚ã¯å¼·ã‚ã®åŠ›ã‚’é©ç”¨
                            baseSpeed = Math.max(currentSpeed * 1.2, 10);
                            
                            // ã‚¯ãƒªã‚¢æ™‚ã®åç™ºåŠ›
                            const clearPower = 1.6;
                            state.ball.vx = Math.cos(angle) * baseSpeed * clearPower + slime.vx * 0.5;
                            state.ball.vy = Math.sin(angle) * baseSpeed * clearPower + slime.vy * 0.5;
                            
                            // ã‚¯ãƒªã‚¢æ™‚ã¯å¿…ãšä¸Šå‘ãã®åŠ›ã‚’ä¿è¨¼
                            if (state.ball.vy > -5) {
                                state.ball.vy = -8; // å¼·åˆ¶çš„ã«ä¸Šå‘ãã«
                            }
                        } else {
                            // é€šå¸¸ã®ç©ºä¸­ã§ã®åç™º
                            baseSpeed = Math.max(currentSpeed * 0.8, 6);
                            
                            const reflectionPower = 1.3;
                            state.ball.vx = Math.cos(angle) * baseSpeed * reflectionPower + slime.vx * 0.4;
                            state.ball.vy = Math.sin(angle) * baseSpeed * reflectionPower + slime.vy * 0.4;
                            
                            // åœ°é¢è¿‘ãã§ã®å½“ãŸã‚Šã®å ´åˆã®ã¿ã€ã‚ãšã‹ã«ä¸Šå‘ãæˆåˆ†ã‚’è¿½åŠ 
                            const slimeGroundY = slime.y + slimeRadius;
                            const ballRelativeY = state.ball.y - slimeGroundY;
                            if (ballRelativeY > -slimeRadius * 0.2 && state.ball.vy > -2) {
                                state.ball.vy -= 3; // è»½ãä¸Šå‘ãã®åŠ›ã‚’è¿½åŠ 
                            }
                        }
                        
                        // æœ€å¤§é€Ÿåº¦åˆ¶é™
                        const newSpeed = Math.sqrt(state.ball.vx * state.ball.vx + state.ball.vy * state.ball.vy);
                        if (newSpeed > MAX_BALL_SPEED) {
                            const scale = MAX_BALL_SPEED / newSpeed;
                            state.ball.vx *= scale;
                            state.ball.vy *= scale;
                        }
                    }
                });
                
                // Goal detection
                if (state.ball.x <= BALL_RADIUS && state.ball.y > groundY - GOAL_HEIGHT) {
                    setScore(prev => ({ ...prev, right: prev.right + 1 }));
                    // ã‚´ãƒ¼ãƒ«åŠ¹æœéŸ³ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªé›»å­éŸ³ï¼‰
                    if (musicEnabled && audioManagerRef.current && window.sfxVolume > 0) {
                        audioManagerRef.current.playGoal();
                    }
                    resetPositions();
                } else if (state.ball.x >= GAME_WIDTH - BALL_RADIUS && state.ball.y > groundY - GOAL_HEIGHT) {
                    setScore(prev => ({ ...prev, left: prev.left + 1 }));
                    // ã‚´ãƒ¼ãƒ«åŠ¹æœéŸ³ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªé›»å­éŸ³ï¼‰
                    if (musicEnabled && audioManagerRef.current && window.sfxVolume > 0) {
                        audioManagerRef.current.playGoal();
                    }
                    resetPositions();
                }
                // Ceiling collision
                if (state.ball.y < BALL_RADIUS) {
                    state.ball.y = BALL_RADIUS;
                    state.ball.vy = -state.ball.vy * BALL_BOUNCE_DAMPING;
                }
            }, [playerCharId, aiCharId, updateAI]);
            
            useEffect(() => {
                if (backgroundImage) {
                    const img = new Image();
                    img.src = backgroundImage;
                    img.onload = () => {
                        backgroundImageRef.current = img;
                        if (gameStarted) draw();
                    };
                    img.onerror = () => {
                        console.log('Background image load error:', backgroundImage);
                        backgroundImageRef.current = null;
                    };
                }
            }, [backgroundImage, gameStarted, draw]);
            
            // draw: èƒŒæ™¯ç”»åƒä»˜ãã®æç”»
            const draw = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const state = gameStateRef.current;
                
                // èƒŒæ™¯ç”»åƒã‚’æç”»ï¼ˆã‚ã‚Œã°ï¼‰
                const bgImg = backgroundImageRef.current;
                if (bgImg) {
                    ctx.drawImage(bgImg, 0, 0, GAME_WIDTH, GAME_HEIGHT);
                } else {
                    // èƒŒæ™¯ç”»åƒãŒãªã„å ´åˆã¯å¾“æ¥ã®é’èƒŒæ™¯
                    ctx.fillStyle = '#0066ff';
                    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                }
                
                // åœ°é¢ï¼ˆèƒŒæ™¯ã®ä¸Šã«åŠé€æ˜ã§æç”»ï¼‰
                ctx.fillStyle = 'rgba(128, 128, 128, 0.8)';
                ctx.fillRect(0, GAME_HEIGHT - GROUND_HEIGHT, GAME_WIDTH, GROUND_HEIGHT);
                
                // --- ã‚´ãƒ¼ãƒ«ã‚¨ãƒªã‚¢è‰²åˆ†ã‘ ---
                ctx.save();
                // å·¦ã‚´ãƒ¼ãƒ«ï¼ˆé’ï¼‰
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#00BFFF';
                ctx.fillRect(0, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT, GOAL_WIDTH, GOAL_HEIGHT);
                // å³ã‚´ãƒ¼ãƒ«ï¼ˆèµ¤ï¼‰
                ctx.fillStyle = '#FF6347';
                ctx.fillRect(GAME_WIDTH - GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT, GOAL_WIDTH, GOAL_HEIGHT);
                ctx.globalAlpha = 1.0;
                ctx.restore();
                
                // --- æ—¢å­˜ã®ã‚´ãƒ¼ãƒ«æ ç·š ---
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                // å·¦ã‚´ãƒ¼ãƒ«
                ctx.beginPath();
                ctx.moveTo(0, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.moveTo(GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
                ctx.stroke();
                // å³ã‚´ãƒ¼ãƒ«
                ctx.beginPath();
                ctx.moveTo(GAME_WIDTH - GOAL_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GAME_WIDTH, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.moveTo(GAME_WIDTH - GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT);
                ctx.lineTo(GAME_WIDTH - GOAL_WIDTH / 2, GAME_HEIGHT - GROUND_HEIGHT - GOAL_HEIGHT);
                ctx.stroke();
                
                // ã‚¹ãƒ©ã‚¤ãƒ æç”»
                const drawSlime = (slime, charId, isAI) => {
                    const stats = getCharStats(charId);
                    // åŠå††ã®ç‰©ç†åˆ¤å®šç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
                    const slimeRadius = getSlimeRadius(charId);
                    // --- é€æ˜ãªåŠå††ï¼ˆå½“ãŸã‚Šåˆ¤å®šç”¨ã€è¦‹ãŸç›®ã«ã¯è¡¨ç¤ºã—ãªã„ï¼‰---
                    ctx.save();
                    ctx.globalAlpha = 0; // å®Œå…¨ã«é€æ˜
                    ctx.beginPath();
                    ctx.arc(slime.x, slime.y, slimeRadius, Math.PI, 0); // yã‚’slime.yã«ä¿®æ­£
                    ctx.closePath();
                    ctx.fillStyle = stats.color;
                    ctx.fill();
                    ctx.restore();
                    // --- ã‚­ãƒ£ãƒ©ç”»åƒã®ä¸‹ç«¯ä¸­å¤®ã‚’åœ°é¢ã«æƒãˆã¦æç”» ---
                    const img = new window.Image();
                    img.src = `images/${charId}.png`;
                    // ç”»åƒãŒæœªãƒ­ãƒ¼ãƒ‰ã®å ´åˆã¯onloadã§å†æç”»ï¼ˆãƒ«ãƒ¼ãƒ—é˜²æ­¢ã®ãŸã‚stateç®¡ç†æ¨å¥¨ã ãŒç°¡æ˜“çš„ã«ï¼‰
                    if (!img.complete) {
                        img.onload = () => draw();
                    }
                    // ç”»åƒã‚µã‚¤ã‚ºå–å¾—
                    const scale = 0.5; // ç”»åƒã‚’åŠåˆ†ã«ç¸®å°
                    const imgWidth = (img.width || 300) * scale;
                    const imgHeight = (img.height || 300) * scale;
                    const imageY = (slime.y + slimeRadius) - imgHeight;
                    ctx.drawImage(
                        img,
                        slime.x - imgWidth / 2,
                        imageY,
                        imgWidth,
                        imgHeight
                    );
                    // --- ã‚­ãƒ£ãƒ©åãƒ»emojiã‚‚ç”»åƒã®ä¸Šã«é€£å‹• ---
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    // èƒŒæ™¯ç”»åƒãŒã‚ã‚‹å ´åˆã¯æ–‡å­—ã‚’è¦‹ã‚„ã™ãã™ã‚‹ãŸã‚å½±ä»˜ã
                    if (backgroundImage) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.strokeText(`${stats.emoji} ${stats.name}`, slime.x, imageY - 10);
                    }
                    ctx.fillStyle = isAI ? '#FFD700' : '#fff';
                    ctx.fillText(`${stats.emoji} ${stats.name}`, slime.x, imageY - 10);
                };
                drawSlime(state.leftSlime, aiCharId, true);
                drawSlime(state.rightSlime, playerCharId, false);
                
                // ãƒœãƒ¼ãƒ«ï¼ˆèƒŒæ™¯ç”»åƒãŒã‚ã‚‹å ´åˆã¯å½±ä»˜ãï¼‰
                if (backgroundImage) {
                    // ãƒœãƒ¼ãƒ«ã®å½±
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(state.ball.x + 2, state.ball.y + 2, BALL_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(state.ball.x, state.ball.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fill();
                
                // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯æç”»
                if (joystickRef.current.active) {
                    // å¤–å††
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(joystickRef.current.centerX, joystickRef.current.centerY, joystickRef.current.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    // å†…ã‚¹ãƒ†ã‚£ãƒƒã‚¯
                    ctx.fillStyle = 'rgba(0, 102, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(joystickRef.current.currentX, joystickRef.current.currentY, 20, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }, [playerCharId, aiCharId, backgroundImage]);
            
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã§updatePhysics, drawã«currentTimeã‚’æ¸¡ã™
            const gameLoop = useCallback((currentTime) => {
                if (gameStarted) {
                    const targetFrameTime = 1000 / 60;
                    if (currentTime - lastFrameTimeRef.current >= targetFrameTime) {
                        updatePhysics(currentTime);
                        draw();
                        lastFrameTimeRef.current = currentTime;
                    }
                    animationRef.current = requestAnimationFrame(gameLoop);
                }
            }, [gameStarted, updatePhysics, draw]);
            
            useEffect(() => {
                if (gameStarted) {
                    animationRef.current = requestAnimationFrame(gameLoop);
                }
                
                return () => {
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                };
            }, [gameStarted, gameLoop]);
            
            // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã«BGMåœæ­¢
            useEffect(() => {
                if (!gameStarted && audioManagerRef.current) {
                    audioManagerRef.current.stopBGM();
                }
            }, [gameStarted]);
            
            // éŸ³æ¥½ON/OFFåˆ‡ã‚Šæ›¿ãˆ
            const toggleMusic = function() {
                setMusicEnabled(function(prev) {
                    const newState = !prev;
                    if (newState && gameStarted && audioManagerRef.current) {
                        // éŸ³æ¥½ã‚’ONã«ã—ã¦ã‚²ãƒ¼ãƒ ä¸­ã®å ´åˆã¯BGMé–‹å§‹
                        audioManagerRef.current.playBGM().catch(function(error) {
                            console.log('BGMé–‹å§‹å¤±æ•—:', error);
                        });
                    } else if (!newState && audioManagerRef.current) {
                        // éŸ³æ¥½ã‚’OFFã«ã™ã‚‹å ´åˆã¯BGMåœæ­¢
                        audioManagerRef.current.stopBGM();
                    }
                    return newState;
                });
            };
            
            // éŸ³é‡èª¿æ•´
            useEffect(() => {
                if (audioManagerRef.current) {
                    audioManagerRef.current.setBGMVolume(bgmVolume);
                    audioManagerRef.current.setSFXVolume(sfxVolume);
                }
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«åŠ¹æœéŸ³éŸ³é‡ã‚’ä¿å­˜
                window.sfxVolume = sfxVolume;
            }, [bgmVolume, sfxVolume]);

            // å…¨ç”»é¢è¡¨ç¤ºã‚’ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹é–¢æ•° (æ©Ÿç¨®ã”ã¨æŸ”è»Ÿå¯¾å¿œ)
            const enterFullscreen = () => {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.log('Fullscreen error:', err));
                } else if (elem.webkitRequestFullscreen) { // iOS Safariå¯¾å¿œ
                    elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT).catch(err => console.log('Fullscreen error:', err));
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen().catch(err => console.log('Fullscreen error:', err));
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen().catch(err => console.log('Fullscreen error:', err));
                }
            };

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼/ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«å…¨ç”»é¢ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆ (ã‚¿ãƒƒãƒ—ã§ãƒˆãƒªã‚¬ãƒ¼)
            useEffect(() => {
                const handleTap = () => {
                    if (!document.fullscreenElement) {
                        enterFullscreen();
                    }
                };
                document.addEventListener('touchstart', handleTap, { once: true }); // åˆå›ã‚¿ãƒƒãƒ—ã§ç™ºå‹•
                return () => document.removeEventListener('touchstart', handleTap);
            }, []);

            return React.createElement('div', {className: "game-container"}, [
                step === 0 && React.createElement('div', {className: "menu-container"}, [
                    React.createElement('h1', null, "ã˜ã‚ƒãŒã‚Šã‚“ã‚¹ãƒ©ã‚¤ãƒ ã‚µãƒƒã‚«ãƒ¼"),
                    React.createElement('h2', null, "ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸ã‚“ã§ãã ã•ã„"),
                    
                    /* éŸ³æ¥½ON/OFFãƒœã‚¿ãƒ³ã¨éŸ³é‡èª¿æ•´ */
                    React.createElement('div', {style: { marginBottom: '20px', textAlign: 'center' }}, [
                        React.createElement('button', {
                            className: "menu-btn",
                            style: { 
                                background: musicEnabled ? '#32CD32' : '#666',
                                fontSize: '14px',
                                padding: '8px 16px',
                                marginBottom: '10px'
                            },
                            onClick: toggleMusic
                        }, `ğŸµ éŸ³æ¥½: ${musicEnabled ? 'ON' : 'OFF'}`),
                        
                        /* BGMå¤‰æ›´ãƒœã‚¿ãƒ³ */
                        musicEnabled && audioManagerRef.current && React.createElement('button', {
                            className: "menu-btn",
                            style: { 
                                background: '#FF6347',
                                fontSize: '12px',
                                padding: '6px 12px',
                                marginBottom: '10px',
                                marginLeft: '10px'
                            },
                            onClick: function() {
                                if (audioManagerRef.current) {
                                    try {
                                        const newBGM = audioManagerRef.current.changeBGM();
                                        console.log('BGMå¤‰æ›´:', newBGM);
                                        if (gameStarted) {
                                            audioManagerRef.current.playBGM().catch(function(error) {
                                                console.log('BGMå†ç”Ÿå¤±æ•—:', error);
                                            });
                                        }
                                    } catch (error) {
                                        console.log('BGMå¤‰æ›´ã‚¨ãƒ©ãƒ¼:', error);
                                    }
                                }
                            }
                        }, "ğŸ”„ BGMå¤‰æ›´"),
                        
                        musicEnabled && React.createElement('div', {style: { display: 'flex', flexDirection: 'column', gap: '8px', alignItems: 'center' }}, [
                            React.createElement('div', {style: { fontSize: '12px', color: '#ccc' }}, [
                                `BGMéŸ³é‡: ${Math.round(bgmVolume * 100)}%`,
                                React.createElement('input', {
                                    type: "range",
                                    min: "0",
                                    max: "1",
                                    step: "0.1",
                                    value: bgmVolume,
                                    onChange: (e) => setBgmVolume(parseFloat(e.target.value)),
                                    style: { marginLeft: '10px', width: '100px' }
                                })
                            ]),
                            React.createElement('div', {style: { fontSize: '12px', color: '#ccc' }}, [
                                `åŠ¹æœéŸ³éŸ³é‡: ${Math.round(sfxVolume * 100)}%`,
                                React.createElement('input', {
                                    type: "range",
                                    min: "0",
                                    max: "1",
                                    step: "0.1",
                                    value: sfxVolume,
                                    onChange: (e) => setSfxVolume(parseFloat(e.target.value)),
                                    style: { marginLeft: '10px', width: '100px' }
                                })
                            ]),
                            React.createElement('div', {style: { fontSize: '10px', color: '#999', textAlign: 'center', maxWidth: '300px' }}, 
                                "ğŸ¼ BGMæ¥½æ›²: ã‚·ãƒ³ã‚°ãƒ«ãƒ™ãƒ«, ã©ãï¼, ã¯ã‚€ãƒ–ãƒ«, ã¶ã¡ã‚ã’, ã¾ã€ã‚‹ã€ã¡ã‚ƒã€ã‚“ï¼, é›¨, æˆ‘ã€…ã¯HamCup, ARE YOU FUMA, Give & Love, HamCupå›½æ­Œ, Hey yo what's up men bro, Tommy's soliloquy 86', ãŠãƒ¼ã•ãƒ¼ã‚†ï¼",
                                React.createElement('br'),
                                "ğŸ”Š åŠ¹æœéŸ³: ã‚·ãƒ³ãƒ—ãƒ«ãªé›»å­éŸ³"
                            )
                        ])
                    ]),
                    React.createElement('div', {className: "character-grid-scroll", style:{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(5, 1fr)',
                        gap: '18px',
                        justifyItems: 'center',
                        maxWidth: 600
                    }}, Object.entries(CHARACTER_STATS).map(([id, char]) => React.createElement('div', {
                        key: id,
                        style: {
                            border: selectedCharacter === id ? '4px solid #FFD700' : '2px solid #333',
                            borderRadius: 12,
                            background: selectedCharacter === id ? '#fffbe6' : '#222',
                            padding: 8,
                            cursor: 'pointer',
                            boxShadow: selectedCharacter === id ? '0 0 12px #FFD700' : 'none',
                            transition: 'all 0.2s',
                            width: 90,
                            textAlign: 'center'
                        },
                        onClick: () => setSelectedCharacter(id)
                    }, [
                        React.createElement('img', {
                            src: `images/${id}.png`,
                            alt: char.name,
                            style: { width: 64, height: 64, borderRadius: 8, background: '#fff' }
                        }),
                        React.createElement('div', {style: { fontWeight: 'bold', marginTop: 4 }}, `${char.emoji} ${char.name}`)
                    ]))),
                    React.createElement('div', {className: "character-select-bottom"}, [
                        selectedCharacter && React.createElement('div', {
                            style: {
                                background: '#222',
                                borderRadius: 12,
                                padding: 16,
                                margin: '0 auto 20px',
                                maxWidth: 340,
                                color: '#fff',
                                boxShadow: '0 2px 8px #0008'
                            }
                        }, [
                            React.createElement('div', {style: { fontSize: 22, fontWeight: 'bold', marginBottom: 6 }}, `${CHARACTER_STATS[selectedCharacter].emoji} ${CHARACTER_STATS[selectedCharacter].name}`),
                            React.createElement('div', {style: { fontSize: 15, marginBottom: 6 }}, [
                                React.createElement('span', {style: { color: '#FFD700' }}, "ç‰¹æŠ€ï¼š"),
                                CHARACTER_STATS[selectedCharacter].specialty
                            ]),
                            React.createElement('div', {style: { display: 'flex', gap: 12, fontSize: 14, justifyContent: 'center' }}, [
                                React.createElement('span', null, `ã‚¹ãƒ”ãƒ¼ãƒ‰: ${CHARACTER_STATS[selectedCharacter].speed}`),
                                React.createElement('span', null, `ã‚¸ãƒ£ãƒ³ãƒ—: ${CHARACTER_STATS[selectedCharacter].jump}`),
                                React.createElement('span', null, `ã‚µã‚¤ã‚º: ${CHARACTER_STATS[selectedCharacter].size}`)
                            ])
                        ]),
                        React.createElement('button', {
                            className: "menu-btn",
                            style: { marginTop: 10, background: selectedCharacter ? '#0066ff' : '#888', cursor: selectedCharacter ? 'pointer' : 'not-allowed' },
                            disabled: !selectedCharacter,
                            onClick: function() {
                                if (!selectedCharacter) return;
                                setPlayerCharId(selectedCharacter);
                                // AIã‚­ãƒ£ãƒ©ã‚’æœªé¸æŠã‚­ãƒ£ãƒ©ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã§æ±ºå®š
                                const aiCandidates = Object.keys(CHARACTER_STATS).filter(function(id) {
                                    return id !== selectedCharacter;
                                });
                                setAiCharId(aiCandidates[Math.floor(Math.random() * aiCandidates.length)]);
                                setStep(1); // é›£æ˜“åº¦é¸æŠã¸
                            }
                        }, "ã“ã®ã‚­ãƒ£ãƒ©ã§æ±ºå®šï¼")
                    ])
                ]),
                step === 1 && React.createElement('div', {className: "menu-container"}, [
                    React.createElement('h2', null, "AIã®é›£æ˜“åº¦ã‚’é¸ã‚“ã§ãã ã•ã„"),
                    React.createElement('div', {className: "menu-buttons"}, [
                        React.createElement('button', {
                            className: "menu-btn",
                            onClick: () => {
                                window.aiDifficulty = { label: 'ã‹ã‚“ãŸã‚“', delay: 500 };
                                setStep(2);
                            }
                        }, [
                            "ã‹ã‚“ãŸã‚“",
                            React.createElement('br'),
                            React.createElement('span', {style: { fontSize: 13, color: '#FFD700' }}, "ï¼ˆåå¿œé…ã‚ï¼‰")
                        ]),
                        React.createElement('button', {
                            className: "menu-btn",
                            onClick: () => {
                                window.aiDifficulty = { label: 'ãµã¤ã†', delay: 200 };
                                setStep(2);
                            }
                        }, [
                            "ãµã¤ã†",
                            React.createElement('br'),
                            React.createElement('span', {style: { fontSize: 13, color: '#00CED1' }}, "ï¼ˆæ¨™æº–ï¼‰")
                        ]),
                        React.createElement('button', {
                            className: "menu-btn",
                            onClick: () => {
                                window.aiDifficulty = { label: 'ã‚€ãšã‹ã—ã„', delay: 0 };
                                setStep(2);
                            }
                        }, [
                            "ã‚€ãšã‹ã—ã„",
                            React.createElement('br'),
                            React.createElement('span', {style: { fontSize: 13, color: '#DC143C' }}, "ï¼ˆå³æ™‚åå¿œï¼‰")
                        ])
                    ]),
                    React.createElement('button', {
                        className: "menu-btn",
                        style: { marginTop: 20, background: '#666' },
                        onClick: () => setStep(0)
                    }, "ã‚­ãƒ£ãƒ©é¸æŠã«æˆ»ã‚‹")
                ]),
                step === 2 && React.createElement('div', {className: "menu-container"}, [
                    React.createElement('h2', null, "è©¦åˆæ™‚é–“ã‚’é¸ã‚“ã§ãã ã•ã„"),
                    React.createElement('div', {className: "game-info"}, [
                        React.createElement('span', {style: { color: CHARACTER_STATS[playerCharId]?.color, fontWeight: 'bold' }},
                            `${CHARACTER_STATS[playerCharId]?.emoji} ${CHARACTER_STATS[playerCharId]?.name}`
                        ),
                        " vs ",
                        React.createElement('span', {style: { color: CHARACTER_STATS[aiCharId]?.color, fontWeight: 'bold' }},
                            `${CHARACTER_STATS[aiCharId]?.emoji} ${CHARACTER_STATS[aiCharId]?.name}`
                        )
                    ]),
                    React.createElement('div', {className: "menu-buttons"}, [
                        React.createElement('button', {className: "menu-btn", onClick: () => { setGameMode('1min'); setTimeLeft(60); setStep(3); setGameStarted(true); resetGame(); }}, "1åˆ†"),
                        React.createElement('button', {className: "menu-btn", onClick: () => { setGameMode('2min'); setTimeLeft(120); setStep(3); setGameStarted(true); resetGame(); }}, "2åˆ†"),
                        React.createElement('button', {className: "menu-btn", onClick: () => { setGameMode('4min'); setTimeLeft(240); setStep(3); setGameStarted(true); resetGame(); }}, "4åˆ†"),
                        React.createElement('button', {className: "menu-btn", onClick: () => { setGameMode('8min'); setTimeLeft(480); setStep(3); setGameStarted(true); resetGame(); }}, "8åˆ†"),
                        React.createElement('button', {className: "menu-btn", onClick: () => { setGameMode('worldcup'); setTimeLeft(300); setStep(3); setGameStarted(true); resetGame(); }}, "ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‚«ãƒƒãƒ—")
                    ]),
                    React.createElement('button', {
                        className: "menu-btn",
                        style: { marginTop: 20, background: '#666' },
                        onClick: () => setStep(1)
                    }, "é›£æ˜“åº¦é¸æŠã«æˆ»ã‚‹")
                ]),
                (gameStarted || winner) && React.createElement(React.Fragment, null, [
                    React.createElement('div', {className: "score-display"}, [
                        React.createElement('span', null, `é’ãƒãƒ¼ãƒ : ${score.left}`),
                        React.createElement('span', null, formatTime(timeLeft)),
                        React.createElement('span', null, `${score.right} : èµ¤ãƒãƒ¼ãƒ `)
                    ]),
                    
                    React.createElement('canvas', {
                        ref: canvasRef,
                        width: GAME_WIDTH,
                        height: GAME_HEIGHT
                    }),
                    
                    // ãƒœã‚¿ãƒ³ãªã—ã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¯ã‚¹ãƒ¯ã‚¤ãƒ—/ã‚¿ãƒƒãƒ—å°‚ç”¨

                    winner && React.createElement('div', {className: "menu-container", style: { position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)', background: 'rgba(0,0,0,0.9)', padding: '30px', borderRadius: '10px' }}, [
                        React.createElement('h2', {style: { fontSize: '2rem', marginBottom: '20px' }}, winner === 'å¼•ãåˆ†ã‘' ? 'å¼•ãåˆ†ã‘ï¼' : `${winner}ã®å‹åˆ©ï¼`),
                        React.createElement('button', {
                            onClick: () => {
                                setStep(0);
                                setGameStarted(false);
                                setGameMode(null);
                                setPlayerCharId(null);
                                setAiCharId(null);
                                setWinner(null);
                                setScore({ left: 0, right: 0 });
                                setTimeLeft(0);
                            },
                            className: "menu-btn"
                        }, "ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹")
                    ])
                ])
            ]);
        };
        
        ReactDOM.render(React.createElement(SlimeSoccerMobile), document.getElementById('root'));
    </script>
</body>
</html>
